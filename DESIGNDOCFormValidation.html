<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=chteh0fSOiSrmusp8u43YLibRAUGyvCIyNwOfYj8c_aH4gUIUjZTH34PuvJkbTJT');.lst-kix_mvuiluyepya3-2>li:before{content:"\0025a0  "}.lst-kix_qltu4xhjazl5-7>li:before{content:"-  "}.lst-kix_qltu4xhjazl5-8>li:before{content:"-  "}.lst-kix_mvuiluyepya3-1>li:before{content:"\0025cb  "}.lst-kix_mvuiluyepya3-3>li:before{content:"\0025cf  "}ul.lst-kix_lr61fncf3c7x-1{list-style-type:none}.lst-kix_mvuiluyepya3-0>li:before{content:"\0025cf  "}.lst-kix_mvuiluyepya3-4>li:before{content:"\0025cb  "}ul.lst-kix_lr61fncf3c7x-0{list-style-type:none}ul.lst-kix_lr61fncf3c7x-3{list-style-type:none}ul.lst-kix_lr61fncf3c7x-2{list-style-type:none}.lst-kix_16ua50byh6-7>li:before{content:"" counter(lst-ctn-kix_16ua50byh6-7,lower-latin) ". "}.lst-kix_mvuiluyepya3-6>li:before{content:"\0025cf  "}.lst-kix_qltu4xhjazl5-4>li:before{content:"-  "}.lst-kix_16ua50byh6-8>li:before{content:"" counter(lst-ctn-kix_16ua50byh6-8,lower-roman) ". "}.lst-kix_mvuiluyepya3-5>li:before{content:"\0025a0  "}.lst-kix_mvuiluyepya3-7>li:before{content:"\0025cb  "}.lst-kix_qltu4xhjazl5-5>li:before{content:"-  "}.lst-kix_qltu4xhjazl5-6>li:before{content:"-  "}.lst-kix_qltu4xhjazl5-0>li:before{content:"-  "}.lst-kix_cjef3nglei0n-6>li:before{content:"" counter(lst-ctn-kix_cjef3nglei0n-6,decimal) ". "}.lst-kix_cjef3nglei0n-7>li:before{content:"" counter(lst-ctn-kix_cjef3nglei0n-7,lower-latin) ". "}.lst-kix_mvuiluyepya3-8>li:before{content:"\0025a0  "}.lst-kix_qltu4xhjazl5-3>li:before{content:"-  "}.lst-kix_cjef3nglei0n-8>li:before{content:"" counter(lst-ctn-kix_cjef3nglei0n-8,lower-roman) ". "}.lst-kix_qltu4xhjazl5-1>li:before{content:"-  "}.lst-kix_qltu4xhjazl5-2>li:before{content:"-  "}ul.lst-kix_hervbur3atu9-5{list-style-type:none}ul.lst-kix_hervbur3atu9-6{list-style-type:none}ul.lst-kix_hervbur3atu9-7{list-style-type:none}.lst-kix_16ua50byh6-0>li:before{content:"" counter(lst-ctn-kix_16ua50byh6-0,decimal) ") "}ul.lst-kix_hervbur3atu9-8{list-style-type:none}.lst-kix_16ua50byh6-1>li:before{content:"" counter(lst-ctn-kix_16ua50byh6-1,lower-latin) ") "}.lst-kix_16ua50byh6-3>li:before{content:"(" counter(lst-ctn-kix_16ua50byh6-3,decimal) ") "}.lst-kix_cjef3nglei0n-5>li:before{content:"(" counter(lst-ctn-kix_cjef3nglei0n-5,lower-roman) ") "}ol.lst-kix_43vsgntzcupx-6.start{counter-reset:lst-ctn-kix_43vsgntzcupx-6 0}.lst-kix_16ua50byh6-2>li:before{content:"" counter(lst-ctn-kix_16ua50byh6-2,lower-roman) ") "}.lst-kix_16ua50byh6-4>li:before{content:"(" counter(lst-ctn-kix_16ua50byh6-4,lower-latin) ") "}.lst-kix_cjef3nglei0n-4>li:before{content:"(" counter(lst-ctn-kix_cjef3nglei0n-4,lower-latin) ") "}ul.lst-kix_hervbur3atu9-0{list-style-type:none}ul.lst-kix_hervbur3atu9-1{list-style-type:none}.lst-kix_cjef3nglei0n-3>li:before{content:"(" counter(lst-ctn-kix_cjef3nglei0n-3,decimal) ") "}ul.lst-kix_hervbur3atu9-2{list-style-type:none}ul.lst-kix_hervbur3atu9-3{list-style-type:none}ul.lst-kix_hervbur3atu9-4{list-style-type:none}.lst-kix_cjef3nglei0n-1>li:before{content:"" counter(lst-ctn-kix_cjef3nglei0n-1,lower-latin) ") "}.lst-kix_16ua50byh6-6>li:before{content:"" counter(lst-ctn-kix_16ua50byh6-6,decimal) ". "}.lst-kix_cjef3nglei0n-0>li:before{content:"" counter(lst-ctn-kix_cjef3nglei0n-0,decimal) ") "}.lst-kix_cjef3nglei0n-2>li:before{content:"" counter(lst-ctn-kix_cjef3nglei0n-2,lower-roman) ") "}.lst-kix_16ua50byh6-5>li:before{content:"(" counter(lst-ctn-kix_16ua50byh6-5,lower-roman) ") "}ol.lst-kix_cjef3nglei0n-7.start{counter-reset:lst-ctn-kix_cjef3nglei0n-7 0}.lst-kix_16ua50byh6-1>li{counter-increment:lst-ctn-kix_16ua50byh6-1}ul.lst-kix_ooujylbyl8du-4{list-style-type:none}ul.lst-kix_ooujylbyl8du-3{list-style-type:none}ul.lst-kix_ooujylbyl8du-2{list-style-type:none}.lst-kix_fms7lhkslz59-8>li:before{content:"\0025a0  "}ul.lst-kix_ooujylbyl8du-1{list-style-type:none}ul.lst-kix_ooujylbyl8du-0{list-style-type:none}.lst-kix_fms7lhkslz59-2>li:before{content:"\0025a0  "}.lst-kix_fms7lhkslz59-4>li:before{content:"\0025cb  "}ul.lst-kix_ooujylbyl8du-8{list-style-type:none}ul.lst-kix_ooujylbyl8du-7{list-style-type:none}ul.lst-kix_ooujylbyl8du-6{list-style-type:none}.lst-kix_fms7lhkslz59-3>li:before{content:"\0025cf  "}.lst-kix_fms7lhkslz59-7>li:before{content:"\0025cb  "}ul.lst-kix_ooujylbyl8du-5{list-style-type:none}.lst-kix_fms7lhkslz59-6>li:before{content:"\0025cf  "}.lst-kix_fms7lhkslz59-5>li:before{content:"\0025a0  "}ol.lst-kix_16ua50byh6-4.start{counter-reset:lst-ctn-kix_16ua50byh6-4 0}ul.lst-kix_lr61fncf3c7x-5{list-style-type:none}ul.lst-kix_lr61fncf3c7x-4{list-style-type:none}ol.lst-kix_43vsgntzcupx-1.start{counter-reset:lst-ctn-kix_43vsgntzcupx-1 0}ul.lst-kix_lr61fncf3c7x-7{list-style-type:none}ol.lst-kix_cjef3nglei0n-2.start{counter-reset:lst-ctn-kix_cjef3nglei0n-2 0}ul.lst-kix_lr61fncf3c7x-6{list-style-type:none}.lst-kix_fms7lhkslz59-0>li:before{content:"\0025cf  "}ul.lst-kix_lr61fncf3c7x-8{list-style-type:none}.lst-kix_fms7lhkslz59-1>li:before{content:"\0025cb  "}.lst-kix_42ef7va21r9z-1>li:before{content:"\0025cb  "}.lst-kix_42ef7va21r9z-3>li:before{content:"\0025cf  "}ol.lst-kix_cjef3nglei0n-5.start{counter-reset:lst-ctn-kix_cjef3nglei0n-5 0}.lst-kix_16ua50byh6-4>li{counter-increment:lst-ctn-kix_16ua50byh6-4}ul.lst-kix_qwmtq0kjlnrc-2{list-style-type:none}ul.lst-kix_qwmtq0kjlnrc-1{list-style-type:none}ul.lst-kix_qwmtq0kjlnrc-0{list-style-type:none}.lst-kix_42ef7va21r9z-7>li:before{content:"\0025cb  "}.lst-kix_rvd88bm3876g-0>li:before{content:"-  "}.lst-kix_42ef7va21r9z-5>li:before{content:"\0025a0  "}.lst-kix_6y1w3c673xwt-1>li:before{content:"\0025cb  "}.lst-kix_43vsgntzcupx-0>li{counter-increment:lst-ctn-kix_43vsgntzcupx-0}.lst-kix_rvd88bm3876g-6>li:before{content:"-  "}.lst-kix_rvd88bm3876g-8>li:before{content:"-  "}.lst-kix_rvd88bm3876g-2>li:before{content:"-  "}.lst-kix_rvd88bm3876g-4>li:before{content:"-  "}ol.lst-kix_16ua50byh6-2.start{counter-reset:lst-ctn-kix_16ua50byh6-2 0}ul.lst-kix_gnv4opshje3l-1{list-style-type:none}ul.lst-kix_gnv4opshje3l-0{list-style-type:none}ul.lst-kix_qwmtq0kjlnrc-6{list-style-type:none}ul.lst-kix_gnv4opshje3l-3{list-style-type:none}ul.lst-kix_qwmtq0kjlnrc-5{list-style-type:none}ul.lst-kix_gnv4opshje3l-2{list-style-type:none}ul.lst-kix_qwmtq0kjlnrc-4{list-style-type:none}ul.lst-kix_gnv4opshje3l-5{list-style-type:none}ul.lst-kix_qwmtq0kjlnrc-3{list-style-type:none}ul.lst-kix_gnv4opshje3l-4{list-style-type:none}ul.lst-kix_gnv4opshje3l-7{list-style-type:none}ul.lst-kix_gnv4opshje3l-6{list-style-type:none}ul.lst-kix_qwmtq0kjlnrc-8{list-style-type:none}ul.lst-kix_qwmtq0kjlnrc-7{list-style-type:none}ul.lst-kix_gnv4opshje3l-8{list-style-type:none}ul.lst-kix_6y1w3c673xwt-8{list-style-type:none}ul.lst-kix_6y1w3c673xwt-7{list-style-type:none}ul.lst-kix_6y1w3c673xwt-6{list-style-type:none}ul.lst-kix_6y1w3c673xwt-5{list-style-type:none}.lst-kix_43vsgntzcupx-7>li{counter-increment:lst-ctn-kix_43vsgntzcupx-7}ul.lst-kix_lz4l53m00pze-0{list-style-type:none}.lst-kix_hervbur3atu9-3>li:before{content:"\0025cf  "}ul.lst-kix_lz4l53m00pze-2{list-style-type:none}ul.lst-kix_lz4l53m00pze-1{list-style-type:none}.lst-kix_cjef3nglei0n-6>li{counter-increment:lst-ctn-kix_cjef3nglei0n-6}ul.lst-kix_lz4l53m00pze-4{list-style-type:none}ul.lst-kix_lz4l53m00pze-3{list-style-type:none}ul.lst-kix_lz4l53m00pze-6{list-style-type:none}ul.lst-kix_lz4l53m00pze-5{list-style-type:none}ul.lst-kix_lz4l53m00pze-8{list-style-type:none}ul.lst-kix_lz4l53m00pze-7{list-style-type:none}.lst-kix_hervbur3atu9-1>li:before{content:"\0025cb  "}ul.lst-kix_mvuiluyepya3-0{list-style-type:none}ul.lst-kix_mvuiluyepya3-1{list-style-type:none}ul.lst-kix_mvuiluyepya3-2{list-style-type:none}ul.lst-kix_mvuiluyepya3-3{list-style-type:none}.lst-kix_2i8l0sqlafj-0>li:before{content:"-  "}.lst-kix_2i8l0sqlafj-4>li:before{content:"-  "}.lst-kix_qwmtq0kjlnrc-6>li:before{content:"-  "}.lst-kix_2i8l0sqlafj-2>li:before{content:"-  "}.lst-kix_qwmtq0kjlnrc-0>li:before{content:"-  "}.lst-kix_qwmtq0kjlnrc-8>li:before{content:"-  "}.lst-kix_6y1w3c673xwt-3>li:before{content:"\0025cf  "}ul.lst-kix_6y1w3c673xwt-4{list-style-type:none}ul.lst-kix_6y1w3c673xwt-3{list-style-type:none}ul.lst-kix_6y1w3c673xwt-2{list-style-type:none}ul.lst-kix_6y1w3c673xwt-1{list-style-type:none}ul.lst-kix_6y1w3c673xwt-0{list-style-type:none}.lst-kix_hervbur3atu9-5>li:before{content:"\0025a0  "}.lst-kix_2i8l0sqlafj-8>li:before{content:"-  "}.lst-kix_qwmtq0kjlnrc-2>li:before{content:"-  "}.lst-kix_6y1w3c673xwt-5>li:before{content:"\0025a0  "}ul.lst-kix_mvuiluyepya3-8{list-style-type:none}.lst-kix_hervbur3atu9-7>li:before{content:"\0025cb  "}ol.lst-kix_16ua50byh6-1.start{counter-reset:lst-ctn-kix_16ua50byh6-1 0}ul.lst-kix_mvuiluyepya3-4{list-style-type:none}ul.lst-kix_mvuiluyepya3-5{list-style-type:none}.lst-kix_6y1w3c673xwt-7>li:before{content:"\0025cb  "}.lst-kix_2i8l0sqlafj-6>li:before{content:"-  "}.lst-kix_16ua50byh6-5>li{counter-increment:lst-ctn-kix_16ua50byh6-5}.lst-kix_qwmtq0kjlnrc-4>li:before{content:"-  "}ul.lst-kix_mvuiluyepya3-6{list-style-type:none}ul.lst-kix_mvuiluyepya3-7{list-style-type:none}.lst-kix_lr61fncf3c7x-7>li:before{content:"-  "}ul.lst-kix_qltu4xhjazl5-7{list-style-type:none}ul.lst-kix_qltu4xhjazl5-8{list-style-type:none}ul.lst-kix_qltu4xhjazl5-5{list-style-type:none}ul.lst-kix_qltu4xhjazl5-6{list-style-type:none}ul.lst-kix_qltu4xhjazl5-3{list-style-type:none}ul.lst-kix_qltu4xhjazl5-4{list-style-type:none}ul.lst-kix_qltu4xhjazl5-1{list-style-type:none}ol.lst-kix_cjef3nglei0n-4.start{counter-reset:lst-ctn-kix_cjef3nglei0n-4 0}ul.lst-kix_qltu4xhjazl5-2{list-style-type:none}ul.lst-kix_qltu4xhjazl5-0{list-style-type:none}.lst-kix_cutwcb6fw09i-7>li:before{content:"-  "}.lst-kix_cjef3nglei0n-7>li{counter-increment:lst-ctn-kix_cjef3nglei0n-7}ul.lst-kix_cutwcb6fw09i-6{list-style-type:none}ul.lst-kix_cutwcb6fw09i-7{list-style-type:none}ul.lst-kix_cutwcb6fw09i-4{list-style-type:none}ul.lst-kix_cutwcb6fw09i-5{list-style-type:none}.lst-kix_cutwcb6fw09i-2>li:before{content:"-  "}ul.lst-kix_cutwcb6fw09i-8{list-style-type:none}ol.lst-kix_cjef3nglei0n-3.start{counter-reset:lst-ctn-kix_cjef3nglei0n-3 0}ul.lst-kix_cutwcb6fw09i-2{list-style-type:none}ul.lst-kix_cutwcb6fw09i-3{list-style-type:none}ul.lst-kix_cutwcb6fw09i-0{list-style-type:none}ul.lst-kix_cutwcb6fw09i-1{list-style-type:none}.lst-kix_umsl9brfcx6g-0>li:before{content:"-  "}.lst-kix_umsl9brfcx6g-4>li:before{content:"-  "}.lst-kix_lr61fncf3c7x-3>li:before{content:"-  "}.lst-kix_lr61fncf3c7x-6>li:before{content:"-  "}.lst-kix_umsl9brfcx6g-3>li:before{content:"-  "}.lst-kix_umsl9brfcx6g-8>li:before{content:"-  "}.lst-kix_cutwcb6fw09i-3>li:before{content:"-  "}.lst-kix_lr61fncf3c7x-2>li:before{content:"-  "}.lst-kix_cutwcb6fw09i-6>li:before{content:"-  "}.lst-kix_umsl9brfcx6g-7>li:before{content:"-  "}.lst-kix_43vsgntzcupx-8>li{counter-increment:lst-ctn-kix_43vsgntzcupx-8}.lst-kix_42ef7va21r9z-0>li:before{content:"\0025cf  "}.lst-kix_ooujylbyl8du-8>li:before{content:"\0025a0  "}.lst-kix_xhvwz2h9vhlu-1>li:before{content:"\0025cb  "}.lst-kix_xhvwz2h9vhlu-5>li:before{content:"\0025a0  "}.lst-kix_42ef7va21r9z-4>li:before{content:"\0025cb  "}.lst-kix_42ef7va21r9z-8>li:before{content:"\0025a0  "}.lst-kix_rvd88bm3876g-1>li:before{content:"-  "}.lst-kix_ooujylbyl8du-4>li:before{content:"\0025cb  "}.lst-kix_16ua50byh6-3>li{counter-increment:lst-ctn-kix_16ua50byh6-3}.lst-kix_6y1w3c673xwt-0>li:before{content:"\0025cf  "}.lst-kix_rvd88bm3876g-5>li:before{content:"-  "}ol.lst-kix_43vsgntzcupx-8{list-style-type:none}.lst-kix_cjef3nglei0n-2>li{counter-increment:lst-ctn-kix_cjef3nglei0n-2}ol.lst-kix_43vsgntzcupx-6{list-style-type:none}ol.lst-kix_43vsgntzcupx-7{list-style-type:none}ol.lst-kix_43vsgntzcupx-4{list-style-type:none}ol.lst-kix_43vsgntzcupx-5{list-style-type:none}ul.lst-kix_2i8l0sqlafj-8{list-style-type:none}.lst-kix_ooujylbyl8du-0>li:before{content:"\0025cf  "}ul.lst-kix_2i8l0sqlafj-7{list-style-type:none}ul.lst-kix_2i8l0sqlafj-6{list-style-type:none}ul.lst-kix_2i8l0sqlafj-5{list-style-type:none}ul.lst-kix_2i8l0sqlafj-4{list-style-type:none}ul.lst-kix_2i8l0sqlafj-3{list-style-type:none}ul.lst-kix_2i8l0sqlafj-2{list-style-type:none}ul.lst-kix_2i8l0sqlafj-1{list-style-type:none}ul.lst-kix_2i8l0sqlafj-0{list-style-type:none}ol.lst-kix_cjef3nglei0n-0.start{counter-reset:lst-ctn-kix_cjef3nglei0n-0 0}.lst-kix_qy1l883yv1pi-4>li:before{content:"-  "}.lst-kix_qy1l883yv1pi-0>li:before{content:"-  "}.lst-kix_qy1l883yv1pi-8>li:before{content:"-  "}.lst-kix_gnv4opshje3l-6>li:before{content:"-  "}ol.lst-kix_43vsgntzcupx-2{list-style-type:none}ol.lst-kix_43vsgntzcupx-3{list-style-type:none}ol.lst-kix_43vsgntzcupx-0{list-style-type:none}.lst-kix_ial5xwbe04de-7>li:before{content:"-  "}ol.lst-kix_43vsgntzcupx-1{list-style-type:none}.lst-kix_hervbur3atu9-2>li:before{content:"\0025a0  "}.lst-kix_lz4l53m00pze-1>li:before{content:"\0025cb  "}.lst-kix_43vsgntzcupx-3>li{counter-increment:lst-ctn-kix_43vsgntzcupx-3}.lst-kix_ial5xwbe04de-3>li:before{content:"-  "}.lst-kix_2i8l0sqlafj-3>li:before{content:"-  "}.lst-kix_qwmtq0kjlnrc-7>li:before{content:"-  "}.lst-kix_6y1w3c673xwt-8>li:before{content:"\0025a0  "}.lst-kix_6y1w3c673xwt-4>li:before{content:"\0025cb  "}.lst-kix_hervbur3atu9-6>li:before{content:"\0025cf  "}.lst-kix_b1mj5qvkewik-3>li:before{content:"-  "}.lst-kix_2i8l0sqlafj-7>li:before{content:"-  "}.lst-kix_qwmtq0kjlnrc-3>li:before{content:"-  "}.lst-kix_16ua50byh6-8>li{counter-increment:lst-ctn-kix_16ua50byh6-8}.lst-kix_gnv4opshje3l-2>li:before{content:"-  "}.lst-kix_b1mj5qvkewik-7>li:before{content:"-  "}.lst-kix_b1mj5qvkewik-6>li:before{content:"-  "}.lst-kix_b1mj5qvkewik-8>li:before{content:"-  "}.lst-kix_43vsgntzcupx-4>li:before{content:"" counter(lst-ctn-kix_43vsgntzcupx-4,lower-latin) ". "}.lst-kix_43vsgntzcupx-6>li:before{content:"" counter(lst-ctn-kix_43vsgntzcupx-6,decimal) ". "}.lst-kix_43vsgntzcupx-5>li{counter-increment:lst-ctn-kix_43vsgntzcupx-5}.lst-kix_b1mj5qvkewik-5>li:before{content:"-  "}.lst-kix_43vsgntzcupx-3>li:before{content:"" counter(lst-ctn-kix_43vsgntzcupx-3,decimal) ". "}.lst-kix_43vsgntzcupx-7>li:before{content:"" counter(lst-ctn-kix_43vsgntzcupx-7,lower-latin) ". "}.lst-kix_43vsgntzcupx-5>li:before{content:"" counter(lst-ctn-kix_43vsgntzcupx-5,lower-roman) ". "}ol.lst-kix_43vsgntzcupx-0.start{counter-reset:lst-ctn-kix_43vsgntzcupx-0 0}.lst-kix_43vsgntzcupx-0>li:before{content:"" counter(lst-ctn-kix_43vsgntzcupx-0,decimal) ". "}.lst-kix_43vsgntzcupx-2>li:before{content:"" counter(lst-ctn-kix_43vsgntzcupx-2,lower-roman) ". "}.lst-kix_43vsgntzcupx-1>li:before{content:"" counter(lst-ctn-kix_43vsgntzcupx-1,lower-latin) ". "}.lst-kix_ial5xwbe04de-0>li:before{content:"-  "}.lst-kix_lz4l53m00pze-8>li:before{content:"\0025a0  "}.lst-kix_ial5xwbe04de-1>li:before{content:"-  "}.lst-kix_cjef3nglei0n-8>li{counter-increment:lst-ctn-kix_cjef3nglei0n-8}.lst-kix_ial5xwbe04de-2>li:before{content:"-  "}ol.lst-kix_cjef3nglei0n-1.start{counter-reset:lst-ctn-kix_cjef3nglei0n-1 0}.lst-kix_lz4l53m00pze-5>li:before{content:"\0025a0  "}.lst-kix_lz4l53m00pze-6>li:before{content:"\0025cf  "}.lst-kix_lz4l53m00pze-7>li:before{content:"\0025cb  "}.lst-kix_43vsgntzcupx-8>li:before{content:"" counter(lst-ctn-kix_43vsgntzcupx-8,lower-roman) ". "}ol.lst-kix_16ua50byh6-3.start{counter-reset:lst-ctn-kix_16ua50byh6-3 0}.lst-kix_16ua50byh6-6>li{counter-increment:lst-ctn-kix_16ua50byh6-6}ul.lst-kix_fms7lhkslz59-6{list-style-type:none}ul.lst-kix_fms7lhkslz59-7{list-style-type:none}ul.lst-kix_fms7lhkslz59-4{list-style-type:none}ul.lst-kix_fms7lhkslz59-5{list-style-type:none}ul.lst-kix_fms7lhkslz59-2{list-style-type:none}ul.lst-kix_fms7lhkslz59-3{list-style-type:none}ul.lst-kix_fms7lhkslz59-0{list-style-type:none}ul.lst-kix_fms7lhkslz59-1{list-style-type:none}ul.lst-kix_fms7lhkslz59-8{list-style-type:none}ul.lst-kix_rvd88bm3876g-0{list-style-type:none}ul.lst-kix_rvd88bm3876g-7{list-style-type:none}ul.lst-kix_rvd88bm3876g-8{list-style-type:none}ul.lst-kix_rvd88bm3876g-5{list-style-type:none}ul.lst-kix_rvd88bm3876g-6{list-style-type:none}.lst-kix_cjef3nglei0n-4>li{counter-increment:lst-ctn-kix_cjef3nglei0n-4}ul.lst-kix_rvd88bm3876g-3{list-style-type:none}.lst-kix_cjef3nglei0n-1>li{counter-increment:lst-ctn-kix_cjef3nglei0n-1}ul.lst-kix_rvd88bm3876g-4{list-style-type:none}ul.lst-kix_rvd88bm3876g-1{list-style-type:none}ul.lst-kix_rvd88bm3876g-2{list-style-type:none}.lst-kix_xhvwz2h9vhlu-4>li:before{content:"\0025cb  "}.lst-kix_xhvwz2h9vhlu-2>li:before{content:"\0025a0  "}.lst-kix_xhvwz2h9vhlu-6>li:before{content:"\0025cf  "}.lst-kix_ooujylbyl8du-3>li:before{content:"\0025cf  "}ul.lst-kix_umsl9brfcx6g-0{list-style-type:none}ul.lst-kix_umsl9brfcx6g-4{list-style-type:none}ul.lst-kix_umsl9brfcx6g-3{list-style-type:none}ul.lst-kix_umsl9brfcx6g-2{list-style-type:none}ol.lst-kix_cjef3nglei0n-8.start{counter-reset:lst-ctn-kix_cjef3nglei0n-8 0}ul.lst-kix_umsl9brfcx6g-1{list-style-type:none}ul.lst-kix_umsl9brfcx6g-8{list-style-type:none}.lst-kix_xhvwz2h9vhlu-8>li:before{content:"\0025a0  "}ul.lst-kix_umsl9brfcx6g-7{list-style-type:none}.lst-kix_ooujylbyl8du-5>li:before{content:"\0025a0  "}ul.lst-kix_umsl9brfcx6g-6{list-style-type:none}ul.lst-kix_umsl9brfcx6g-5{list-style-type:none}.lst-kix_ooujylbyl8du-7>li:before{content:"\0025cb  "}ol.lst-kix_16ua50byh6-0.start{counter-reset:lst-ctn-kix_16ua50byh6-0 0}.lst-kix_cjef3nglei0n-5>li{counter-increment:lst-ctn-kix_cjef3nglei0n-5}.lst-kix_ooujylbyl8du-1>li:before{content:"\0025cb  "}.lst-kix_43vsgntzcupx-1>li{counter-increment:lst-ctn-kix_43vsgntzcupx-1}.lst-kix_xhvwz2h9vhlu-0>li:before{content:"\0025cf  "}.lst-kix_gnv4opshje3l-3>li:before{content:"-  "}.lst-kix_gnv4opshje3l-5>li:before{content:"-  "}.lst-kix_qy1l883yv1pi-1>li:before{content:"-  "}.lst-kix_qy1l883yv1pi-5>li:before{content:"-  "}.lst-kix_gnv4opshje3l-7>li:before{content:"-  "}.lst-kix_qy1l883yv1pi-7>li:before{content:"-  "}.lst-kix_lz4l53m00pze-0>li:before{content:"\0025cf  "}.lst-kix_cjef3nglei0n-0>li{counter-increment:lst-ctn-kix_cjef3nglei0n-0}.lst-kix_ial5xwbe04de-6>li:before{content:"-  "}.lst-kix_ial5xwbe04de-4>li:before{content:"-  "}.lst-kix_lz4l53m00pze-4>li:before{content:"\0025cb  "}.lst-kix_lz4l53m00pze-2>li:before{content:"\0025a0  "}.lst-kix_qy1l883yv1pi-3>li:before{content:"-  "}ol.lst-kix_cjef3nglei0n-6.start{counter-reset:lst-ctn-kix_cjef3nglei0n-6 0}ul.lst-kix_ial5xwbe04de-0{list-style-type:none}ul.lst-kix_ial5xwbe04de-2{list-style-type:none}ul.lst-kix_ial5xwbe04de-1{list-style-type:none}ul.lst-kix_ial5xwbe04de-4{list-style-type:none}ul.lst-kix_ial5xwbe04de-3{list-style-type:none}ul.lst-kix_ial5xwbe04de-6{list-style-type:none}ul.lst-kix_ial5xwbe04de-5{list-style-type:none}ul.lst-kix_ial5xwbe04de-8{list-style-type:none}ul.lst-kix_ial5xwbe04de-7{list-style-type:none}.lst-kix_ial5xwbe04de-8>li:before{content:"-  "}.lst-kix_b1mj5qvkewik-0>li:before{content:"-  "}.lst-kix_b1mj5qvkewik-4>li:before{content:"-  "}.lst-kix_b1mj5qvkewik-2>li:before{content:"-  "}.lst-kix_gnv4opshje3l-1>li:before{content:"-  "}ol.lst-kix_16ua50byh6-8{list-style-type:none}ol.lst-kix_16ua50byh6-6{list-style-type:none}ol.lst-kix_16ua50byh6-7{list-style-type:none}.lst-kix_lr61fncf3c7x-8>li:before{content:"-  "}ul.lst-kix_xhvwz2h9vhlu-2{list-style-type:none}ul.lst-kix_xhvwz2h9vhlu-3{list-style-type:none}ul.lst-kix_xhvwz2h9vhlu-0{list-style-type:none}ul.lst-kix_xhvwz2h9vhlu-1{list-style-type:none}ol.lst-kix_16ua50byh6-4{list-style-type:none}ol.lst-kix_16ua50byh6-5{list-style-type:none}ul.lst-kix_xhvwz2h9vhlu-8{list-style-type:none}.lst-kix_43vsgntzcupx-6>li{counter-increment:lst-ctn-kix_43vsgntzcupx-6}ol.lst-kix_16ua50byh6-2{list-style-type:none}ol.lst-kix_16ua50byh6-3{list-style-type:none}ul.lst-kix_xhvwz2h9vhlu-6{list-style-type:none}ol.lst-kix_16ua50byh6-0{list-style-type:none}ul.lst-kix_xhvwz2h9vhlu-7{list-style-type:none}ol.lst-kix_16ua50byh6-1{list-style-type:none}ul.lst-kix_xhvwz2h9vhlu-4{list-style-type:none}ul.lst-kix_xhvwz2h9vhlu-5{list-style-type:none}ol.lst-kix_43vsgntzcupx-3.start{counter-reset:lst-ctn-kix_43vsgntzcupx-3 0}.lst-kix_43vsgntzcupx-4>li{counter-increment:lst-ctn-kix_43vsgntzcupx-4}.lst-kix_cutwcb6fw09i-8>li:before{content:"-  "}.lst-kix_43vsgntzcupx-2>li{counter-increment:lst-ctn-kix_43vsgntzcupx-2}.lst-kix_16ua50byh6-7>li{counter-increment:lst-ctn-kix_16ua50byh6-7}ul.lst-kix_qy1l883yv1pi-6{list-style-type:none}ul.lst-kix_qy1l883yv1pi-7{list-style-type:none}ul.lst-kix_qy1l883yv1pi-4{list-style-type:none}ul.lst-kix_qy1l883yv1pi-5{list-style-type:none}ul.lst-kix_qy1l883yv1pi-8{list-style-type:none}.lst-kix_cutwcb6fw09i-0>li:before{content:"-  "}.lst-kix_cutwcb6fw09i-1>li:before{content:"-  "}ol.lst-kix_43vsgntzcupx-2.start{counter-reset:lst-ctn-kix_43vsgntzcupx-2 0}.lst-kix_16ua50byh6-0>li{counter-increment:lst-ctn-kix_16ua50byh6-0}.lst-kix_lr61fncf3c7x-0>li:before{content:"-  "}.lst-kix_umsl9brfcx6g-1>li:before{content:"-  "}.lst-kix_umsl9brfcx6g-2>li:before{content:"-  "}.lst-kix_lr61fncf3c7x-4>li:before{content:"-  "}ol.lst-kix_43vsgntzcupx-8.start{counter-reset:lst-ctn-kix_43vsgntzcupx-8 0}.lst-kix_lr61fncf3c7x-5>li:before{content:"-  "}.lst-kix_cutwcb6fw09i-4>li:before{content:"-  "}.lst-kix_umsl9brfcx6g-5>li:before{content:"-  "}.lst-kix_umsl9brfcx6g-6>li:before{content:"-  "}.lst-kix_lr61fncf3c7x-1>li:before{content:"-  "}.lst-kix_cutwcb6fw09i-5>li:before{content:"-  "}.lst-kix_42ef7va21r9z-2>li:before{content:"\0025a0  "}.lst-kix_xhvwz2h9vhlu-3>li:before{content:"\0025cf  "}ol.lst-kix_43vsgntzcupx-4.start{counter-reset:lst-ctn-kix_43vsgntzcupx-4 0}.lst-kix_42ef7va21r9z-6>li:before{content:"\0025cf  "}.lst-kix_6y1w3c673xwt-2>li:before{content:"\0025a0  "}ol.lst-kix_16ua50byh6-8.start{counter-reset:lst-ctn-kix_16ua50byh6-8 0}.lst-kix_cjef3nglei0n-3>li{counter-increment:lst-ctn-kix_cjef3nglei0n-3}ol.lst-kix_43vsgntzcupx-7.start{counter-reset:lst-ctn-kix_43vsgntzcupx-7 0}.lst-kix_ooujylbyl8du-6>li:before{content:"\0025cf  "}.lst-kix_xhvwz2h9vhlu-7>li:before{content:"\0025cb  "}ol.lst-kix_16ua50byh6-5.start{counter-reset:lst-ctn-kix_16ua50byh6-5 0}.lst-kix_rvd88bm3876g-7>li:before{content:"-  "}ul.lst-kix_b1mj5qvkewik-7{list-style-type:none}ul.lst-kix_b1mj5qvkewik-6{list-style-type:none}ul.lst-kix_b1mj5qvkewik-5{list-style-type:none}ul.lst-kix_b1mj5qvkewik-4{list-style-type:none}ul.lst-kix_b1mj5qvkewik-3{list-style-type:none}ul.lst-kix_b1mj5qvkewik-2{list-style-type:none}ul.lst-kix_b1mj5qvkewik-1{list-style-type:none}ul.lst-kix_b1mj5qvkewik-0{list-style-type:none}.lst-kix_rvd88bm3876g-3>li:before{content:"-  "}ul.lst-kix_b1mj5qvkewik-8{list-style-type:none}.lst-kix_ooujylbyl8du-2>li:before{content:"\0025a0  "}ul.lst-kix_qy1l883yv1pi-2{list-style-type:none}ul.lst-kix_qy1l883yv1pi-3{list-style-type:none}ul.lst-kix_qy1l883yv1pi-0{list-style-type:none}ul.lst-kix_qy1l883yv1pi-1{list-style-type:none}.lst-kix_qy1l883yv1pi-2>li:before{content:"-  "}ol.lst-kix_16ua50byh6-6.start{counter-reset:lst-ctn-kix_16ua50byh6-6 0}.lst-kix_gnv4opshje3l-0>li:before{content:"-  "}.lst-kix_gnv4opshje3l-4>li:before{content:"-  "}.lst-kix_qy1l883yv1pi-6>li:before{content:"-  "}ol.lst-kix_cjef3nglei0n-2{list-style-type:none}ol.lst-kix_cjef3nglei0n-1{list-style-type:none}ol.lst-kix_cjef3nglei0n-4{list-style-type:none}ol.lst-kix_cjef3nglei0n-3{list-style-type:none}ol.lst-kix_43vsgntzcupx-5.start{counter-reset:lst-ctn-kix_43vsgntzcupx-5 0}ol.lst-kix_cjef3nglei0n-0{list-style-type:none}.lst-kix_gnv4opshje3l-8>li:before{content:"-  "}.lst-kix_hervbur3atu9-0>li:before{content:"\0025cf  "}.lst-kix_ial5xwbe04de-5>li:before{content:"-  "}ol.lst-kix_cjef3nglei0n-6{list-style-type:none}ol.lst-kix_cjef3nglei0n-5{list-style-type:none}.lst-kix_lz4l53m00pze-3>li:before{content:"\0025cf  "}ol.lst-kix_cjef3nglei0n-8{list-style-type:none}ol.lst-kix_cjef3nglei0n-7{list-style-type:none}ul.lst-kix_42ef7va21r9z-5{list-style-type:none}ul.lst-kix_42ef7va21r9z-4{list-style-type:none}ul.lst-kix_42ef7va21r9z-7{list-style-type:none}ul.lst-kix_42ef7va21r9z-6{list-style-type:none}ul.lst-kix_42ef7va21r9z-1{list-style-type:none}.lst-kix_2i8l0sqlafj-1>li:before{content:"-  "}.lst-kix_2i8l0sqlafj-5>li:before{content:"-  "}ul.lst-kix_42ef7va21r9z-0{list-style-type:none}ul.lst-kix_42ef7va21r9z-3{list-style-type:none}ul.lst-kix_42ef7va21r9z-2{list-style-type:none}.lst-kix_qwmtq0kjlnrc-1>li:before{content:"-  "}ul.lst-kix_42ef7va21r9z-8{list-style-type:none}ol.lst-kix_16ua50byh6-7.start{counter-reset:lst-ctn-kix_16ua50byh6-7 0}.lst-kix_hervbur3atu9-4>li:before{content:"\0025cb  "}.lst-kix_b1mj5qvkewik-1>li:before{content:"-  "}.lst-kix_16ua50byh6-2>li{counter-increment:lst-ctn-kix_16ua50byh6-2}.lst-kix_hervbur3atu9-8>li:before{content:"\0025a0  "}.lst-kix_6y1w3c673xwt-6>li:before{content:"\0025cf  "}.lst-kix_qwmtq0kjlnrc-5>li:before{content:"-  "}ol{margin:0;padding:0}table td,table th{padding:0}.c8{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#e0e0e0;border-top-width:1pt;border-right-width:1pt;border-left-color:#e0e0e0;vertical-align:top;border-right-color:#e0e0e0;border-left-width:1pt;border-top-style:solid;background-color:#fafafa;border-left-style:solid;border-bottom-width:1pt;width:468pt;border-top-color:#e0e0e0;border-bottom-style:solid}.c61{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#e0e0e0;border-top-width:1pt;border-right-width:1pt;border-left-color:#e0e0e0;vertical-align:top;border-right-color:#e0e0e0;border-left-width:1pt;border-top-style:solid;background-color:#fafafa;border-left-style:solid;border-bottom-width:1pt;width:469.5pt;border-top-color:#e0e0e0;border-bottom-style:solid}.c26{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:234pt;border-top-color:#000000;border-bottom-style:solid}.c1{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:156pt;border-top-color:#000000;border-bottom-style:solid}.c37{-webkit-text-decoration-skip:none;color:#000000;text-decoration:underline;vertical-align:baseline;text-decoration-skip-ink:none;font-size:11pt;font-style:normal}.c5{color:#000000;text-decoration:none;vertical-align:baseline;font-size:11pt;font-style:normal}.c20{color:#000000;text-decoration:none;vertical-align:baseline;font-size:11pt;font-style:italic}.c30{padding-top:10pt;padding-bottom:4pt;line-height:1.15;page-break-after:avoid;text-align:left}.c43{font-size:10pt;font-family:"Consolas";color:#0f9d58;font-weight:400}.c47{font-size:10pt;font-family:"Consolas";color:#455a64;font-weight:400}.c35{color:#999999;font-weight:400;font-size:10pt;font-family:"Consolas"}.c14{font-size:10pt;font-family:"Consolas";color:#9c27b0;font-weight:400}.c57{color:#434343;vertical-align:baseline;font-size:14pt;font-style:normal}.c45{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:center}.c16{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c0{font-size:10pt;font-family:"Consolas";color:#616161;font-weight:400}.c10{color:#000000;font-weight:400;font-size:21pt;font-family:"Trebuchet MS"}.c11{font-size:10pt;font-family:"Consolas";color:#c53929;font-weight:400}.c21{font-size:10pt;font-family:"Consolas";color:#00796b;font-weight:400}.c9{padding-top:14pt;padding-bottom:4pt;line-height:1.15;text-align:left}.c13{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c31{border-spacing:0;border-collapse:collapse;margin-right:auto}.c38{font-size:12pt;font-family:"Consolas";color:#0f9d58;font-weight:400}.c46{padding-top:10pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c17{font-size:10pt;font-family:"Consolas";color:#3367d6;font-weight:400}.c3{font-size:10pt;font-family:"Consolas";color:#000000;font-weight:400}.c58{color:#434343;text-decoration:none;vertical-align:baseline;font-size:14pt}.c2{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c55{padding-top:0pt;padding-bottom:4pt;line-height:1.15;text-align:center}.c41{margin-left:-1.5pt;border-spacing:0;border-collapse:collapse;margin-right:auto}.c52{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c6{text-decoration:none;vertical-align:baseline;font-style:normal}.c49{font-size:10pt;font-family:"Consolas";font-weight:400}.c44{text-decoration:none;vertical-align:baseline;font-size:11pt}.c29{font-family:"Consolas";color:#0d904f;font-weight:400}.c12{orphans:2;widows:2;height:11pt}.c51{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;text-decoration:underline}.c23{font-weight:700;font-family:"Open Sans"}.c33{padding:0;margin:0}.c25{orphans:2;widows:2}.c4{font-weight:400;font-family:"Open Sans"}.c18{font-style:italic;color:#666666}.c34{color:#000000;font-size:20pt}.c15{color:inherit;text-decoration:inherit}.c40{font-weight:700;font-family:"Arial"}.c39{color:#000000;font-size:16pt}.c27{color:#999999;font-size:11pt}.c62{vertical-align:baseline;font-style:normal}.c7{font-weight:400;font-family:"Arial"}.c19{margin-left:36pt;padding-left:0pt}.c50{font-size:12pt;color:#0f9d58}.c53{color:#999999}.c54{background-color:#ff0000}.c60{color:#0f9d58}.c56{font-weight:700}.c28{height:11pt}.c32{font-style:italic}.c59{height:26pt}.c63{font-size:11pt}.c22{height:0pt}.c48{color:#980000}.c24{background-color:#00ff00}.c36{page-break-after:avoid}.c42{font-size:16pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c52"><div><p class="c2 c12"><span class="c5 c7"></span></p></div><p class="c2 c12"><span class="c5 c7"></span></p><p class="c45 c36 title" id="h.xgjl2srtytjt"><span class="c6 c10">Form Validators Design Doc</span></p><p class="c45"><span class="c5 c4">author: Kara Erickson</span></p><p class="c45"><span class="c4">last update: 2017-3-13</span></p><p class="c45"><span class="c4">Status: </span><span class="c23 c24">in review</span></p><p class="c45"><span class="c18 c7 c44">design doc template version: 1.2.0</span></p><p class="c55"><span class="c32 c48">This document is published in a </span><span class="c16 c32"><a class="c15" href="https://www.google.com/url?q=https://drive.google.com/drive/folders/0B6kTPDa3TSReZ2d4bV9uTGhEeGc&amp;sa=D&amp;ust=1514893617348000&amp;usg=AFQjCNH7F4-POthC7RjeOqV24pfPREFpiQ">shared folder on the angular.io domain</a></span><span class="c32 c48">,<br>and possibly </span><span class="c32 c48 c56">publicly accessible</span><span class="c32 c48">.</span></p><h1 class="c30" id="h.fxpk50cps4zs"><span class="c4 c42">Objective</span></h1><ul class="c33 lst-kix_b1mj5qvkewik-0 start"><li class="c9 c19"><span class="c5 c4">Give developers more control over how and when validation runs</span></li><li class="c9 c19"><span class="c5 c4">Promote observable support to first-class </span></li><li class="c9 c19"><span class="c5 c4">Facilitate debouncing the display of validation styles</span></li></ul><h1 class="c9 c36" id="h.52itl9qigzx3"><span class="c4 c42">Approvals</span></h1><p class="c9"><span class="c5 c4">We are seeking for approval from the following people:</span></p><ul class="c33 lst-kix_6y1w3c673xwt-0 start"><li class="c9 c19"><span class="c4">component owner: karakara@ [</span><span class="c4 c24">OK]</span></li><li class="c9 c19"><span class="c4">Angular: misko@ [ ], iminar@ [</span><span class="c4 c24">OK]</span></li><li class="c9 c19"><span class="c4">Devrel: stephenfluin@ [</span><span class="c4 c24">OK]</span><span class="c4">, robwormald@ [ ]</span></li><li class="c9 c19"><span class="c5 c4">Forms: @tinagao [ ]</span></li></ul><h1 class="c30" id="h.wwgnimruvhlu"><span class="c4 c42">Quick Validator Overview</span></h1><p class="c9"><span class="c5 c4">Validator functions are used to calculate a new validation status when a form control&#39;s value changes. &nbsp;</span></p><p class="c9"><span class="c5 c4">Controls can be VALID (no errors), INVALID (some errors), PENDING (unknown errors), or DISABLED (disabled from running validation).</span></p><p class="c9"><span class="c5 c4">There are currently two types of validators:</span></p><ul class="c33 lst-kix_hervbur3atu9-0 start"><li class="c9 c19"><span class="c23">ValidatorFn</span><span class="c4">: takes an </span><span class="c29">AbstractControl*</span><span class="c4">&nbsp;and returns </span><span class="c29">null</span><span class="c5 c4">&nbsp;if the control is VALID or a map of errors if the control is INVALID.<br></span></li><li class="c9 c19"><span class="c23">AsyncValidatorFn</span><span class="c4">: takes an </span><span class="c29">AbstractControl</span><span class="c4">&nbsp;and returns an observable or promise, which then emits </span><span class="c29">null</span><span class="c5 c4">&nbsp;for VALID or an error map for INVALID.</span></li></ul><p class="c9"><span class="c4">*Superclass of </span><span class="c29">FormControl</span><span class="c4">, </span><span class="c29">FormGroup</span><span class="c4">, and </span><span class="c29">FormArray</span></p><p class="c9"><span class="c5 c4">We have some built-in validator functions developers can use out of the box. They include:</span></p><ul class="c33 lst-kix_mvuiluyepya3-0 start"><li class="c9 c19"><span class="c5 c4">Validators.required</span></li><li class="c9 c19"><span class="c5 c4">Validators.minLength</span></li><li class="c9 c19"><span class="c5 c4">Validators.maxLength</span></li><li class="c9 c19"><span class="c5 c4">Validators.pattern</span></li><li class="c9 c19"><span class="c5 c4">Validators.email</span></li></ul><p class="c9"><span class="c37 c4">Usage: Template-driven forms</span></p><p class="c9"><span class="c5 c4">In template-driven forms, the built-in validator functions have been wrapped into directives. This way, it&#39;s easy for people to use standard HTML5 syntax to define validators.<br></span></p><a id="t.4db211218373456d38916d8edc9a8b4a2e42c26d"></a><a id="t.0"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c21">&lt;input</span><span class="c3">&nbsp;[(ngModel)]</span><span class="c0">=</span><span class="c3">&quot;name&quot; required minlength</span><span class="c0">=</span><span class="c3">&quot;3&quot;</span><span class="c21">&gt;</span></p></td></tr></tbody></table><p class="c9"><span class="c51 c4">Usage: Reactive forms</span></p><p class="c9"><span class="c4">In reactive forms, the simplest way to define validators is to pass them in when instantiating the </span><span class="c29">FormControl</span><span class="c4">: </span><span class="c4">validators in the second position, async validators in the third position. </span></p><a id="t.0053c810ca3224db5bf960e30fffc5035d76dd90"></a><a id="t.1"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c14">const</span><span class="c3">&nbsp;c </span><span class="c0">=</span><span class="c3">&nbsp;</span><span class="c14">new</span><span class="c3">&nbsp;</span><span class="c17">FormControl</span><span class="c0">(</span><span class="c43">&#39;&#39;</span><span class="c0">,</span><span class="c3">&nbsp;</span><span class="c17">Validators</span><span class="c0">.</span><span class="c3">required</span><span class="c0">,</span><span class="c3">&nbsp;myAsyncValidator</span><span class="c0">);</span></p></td></tr></tbody></table><p class="c9"><span class="c5 c4">Multiple sync or async validators can be passed in by wrapping the validators in an array.</span></p><a id="t.9ad00d12d1edf60cd0b44d84614bd09f937754a5"></a><a id="t.2"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c14">const</span><span class="c3">&nbsp;c </span><span class="c0">=</span><span class="c3">&nbsp;</span><span class="c14">new</span><span class="c3">&nbsp;</span><span class="c17">FormControl</span><span class="c0">(</span><span class="c43">&#39;&#39;</span><span class="c0">,</span><span class="c3">&nbsp;</span><span class="c0">[</span><span class="c17">Validators</span><span class="c0">.</span><span class="c3">required</span><span class="c0">,</span><span class="c3">&nbsp;</span><span class="c17">Validators</span><span class="c0">.</span><span class="c3">minLength</span><span class="c0">(</span><span class="c11">3</span><span class="c0">)]);</span></p></td></tr></tbody></table><p class="c9"><span class="c37 c4">Current validation pipeline</span></p><p class="c9"><span class="c5 c4">When the value of a field changes, the following happens internally:</span></p><ul class="c33 lst-kix_ial5xwbe04de-0 start"><li class="c9 c19"><span class="c5 c4">Any previous async validators in flight are canceled.</span></li><li class="c9 c19"><span class="c5 c4">The sync validator functions are run and set an initial validation status.</span></li><li class="c9 c19"><span class="c5 c4">If the status is VALID or PENDING based on the sync validators, the async validators are run. Status is set to PENDING.</span></li><li class="c9 c19"><span class="c5 c4">Any promises returned by async validators are converted into observables. </span></li><li class="c9 c19"><span class="c5 c4">We forkJoin the resulting observables and subscribe to the result.</span></li><li class="c9 c19"><span class="c5 c4">Once all the observables complete, validation status and errors are updated.</span></li><li class="c9 c19"><span class="c5 c4">Validation status and errors are updated up the tree (the field&#39;s parent is updated, then its parent, and so on).</span></li></ul><p class="c9"><span class="c37 c4">Styling the UI based on control state</span></p><p class="c9"><span class="c5 c4">The rule of thumb to date has been that the framework controls when validation runs, but the developer controls how and when the UI updates in response. </span></p><p class="c9"><span class="c4">For example, if you wanted to display errors only after the control was touched, you could use a simple </span><span class="c29">*ngIf</span><span class="c5 c4">&nbsp;to gate messages based on the control&#39;s existing properties.</span></p><a id="t.6837776bdeffc9b2ae45637bddda2f8dc5d2386b"></a><a id="t.3"></a><table class="c31"><tbody><tr class="c59"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c21">&lt;div</span><span class="c3">&nbsp;*ngIf</span><span class="c0">=</span><span class="c3">&quot;ctrl.touched &amp;&amp; ctrl.invalid&quot;</span><span class="c21">&gt;</span><span class="c3">&nbsp;This field is invalid. </span><span class="c21">&lt;/div&gt;</span></p></td></tr></tbody></table><p class="c9 c28"><span class="c5 c4"></span></p><h1 class="c30" id="h.qy7r8l1j6tmx"><span class="c4 c42">Outstanding Issues</span></h1><a id="kix.ohyn6trawk0t"></a><p class="c9"><span class="c4 c37">Problem 1: &nbsp;Rate-limiting or delaying validation doesn&#39;t quite work</span></p><p class="c9"><span class="c4">Currently, it&#39;s trivial to debounce an app&#39;s </span><span class="c4 c32">response</span><span class="c4">&nbsp;to value or validation status changes by subscribing to the </span><span class="c29">valueChanges</span><span class="c4">&nbsp;and </span><span class="c29">statusChanges</span><span class="c4">&nbsp;observables. However, it&#39;s not possible to properly debounce when validation itself runs. </span><span class="c4">Validators will always run on every value change. </span></p><p class="c9"><span class="c4">This setup is sufficient to handle most simple use cases. But let&#39;s say that you had an async validator checking on the server to check whether a specific username was taken. You&#39;d likely use </span><span class="c29">http.get()</span><span class="c5 c4">&nbsp;from our HTTPModule, which returns an observable.</span></p><a id="t.2d1ea030a05452c4e883e9a2cdbc007089d8e2b2"></a><a id="t.4"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c3">validate</span><span class="c0">(</span><span class="c3">ctrl</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c17">AbstractControl</span><span class="c0">):</span><span class="c3">&nbsp;</span><span class="c17">Observable</span><span class="c0">&lt;</span><span class="c17">ValidationErrors</span><span class="c0">|</span><span class="c14">null</span><span class="c0">&gt;</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c14">return</span><span class="c3">&nbsp;</span><span class="c14">this</span><span class="c0">.</span><span class="c3">_http</span><span class="c0">.</span><span class="c14">get</span><span class="c0">(</span><span class="c43">`/my/async/endpoint?username=${ctrl.value}`</span><span class="c0">)</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; </span><span class="c0">.</span><span class="c3">map</span><span class="c0">(</span><span class="c3">resp </span><span class="c0">=&gt;</span><span class="c3">&nbsp;resp</span><span class="c0">.</span><span class="c3">json</span><span class="c0">().</span><span class="c3">exists </span><span class="c0">?</span><span class="c3">&nbsp;</span><span class="c0">{</span><span class="c3">exists</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c14">true</span><span class="c0">}</span><span class="c3">&nbsp;</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c14">null</span><span class="c0">);</span></p><p class="c2"><span class="c0">}</span></p></td></tr></tbody></table><p class="c9"><span class="c5 c4">Internally, the module subscribes to the returned observable and will update the tree&#39;s validation status when it completes. &nbsp;</span></p><p class="c9"><span class="c5 c4">With every value change, any previous subscription is canceled and a new subscription is created. Every time a character is typed, the HTTP request is aborted and a new one is created. &nbsp;So if the end user types 10 characters, there will be 10 HTTP requests created, 9 aborted at the next value change. Aborting the requests ensures that the client won&#39;t wait for responses it doesn&#39;t care about, but the server may still process the requests, which could still potentially be expensive. </span></p><p class="c9"><span class="c5 c4">One typical solution is to rate limit the HTTP requests themselves by throttling or debouncing user input. That way, no requests are sent until a certain period of inactivity from the user has passed. </span></p><p class="c9"><span class="c5 c4">However, as it stands, async validator functions only receive the control instance, not an existing observable chain that can be debounced before sending off the http request. It&#39;s not immediately clear how to make this work. &nbsp;</span></p><a id="t.6150096e0abfc92de82aa84668729af62c87c994"></a><a id="t.5"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c3">validate</span><span class="c0">(</span><span class="c3">ctrl</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c17">AbstractControl</span><span class="c0">):</span><span class="c3">&nbsp;</span><span class="c17">Observable</span><span class="c0">&lt;</span><span class="c17">ValidationErrors</span><span class="c0">|</span><span class="c14">null</span><span class="c0">&gt;</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c47">// Where does the debounce go? No observable to debounce before the request.</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c14">return</span><span class="c3">&nbsp;</span><span class="c14">this</span><span class="c0">.</span><span class="c3">_http</span><span class="c0">.</span><span class="c14">get</span><span class="c0">(</span><span class="c43">`/my/async/endpoint?username=${ctrl.value}`</span><span class="c0">)</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; </span><span class="c0">.</span><span class="c3">map</span><span class="c0">(</span><span class="c3">resp </span><span class="c0">=&gt;</span><span class="c3">&nbsp;resp</span><span class="c0">.</span><span class="c3">json</span><span class="c0">().</span><span class="c3">exists </span><span class="c0">?</span><span class="c3">&nbsp;</span><span class="c0">{</span><span class="c3">exists</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c14">true</span><span class="c0">}</span><span class="c3">&nbsp;</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c14">null</span><span class="c0">);</span></p><p class="c2"><span class="c0">}</span></p></td></tr></tbody></table><p class="c9"><span class="c5 c4">As a workaround, you could technically create your own source observable to debounce, but this feels hackish and it would be reset every value change anyway.</span></p><p class="c9"><span class="c4">Some developers have started to work outside of our normal validator pipeline to solve this problem. Instead of creating an async validator, they create their own </span><span class="c29">valueChanges</span><span class="c4">&nbsp;subscription in the component class and call </span><span class="c29">setErrors()</span><span class="c5 c4">&nbsp;after debounce to manually override the errors produced by normal validation.</span></p><a id="t.f39c7b569bce2aa90a62ba8340ab452147835f0e"></a><a id="t.6"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><a id="id.k0r0kco0ou80"></a><p class="c2"><span class="c3">ngOnInit</span><span class="c0">()</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c14">this</span><span class="c0">.</span><span class="c14">sub</span><span class="c3">&nbsp;</span><span class="c0">=</span><span class="c3">&nbsp;</span><span class="c14">this</span><span class="c0">.</span><span class="c3">ctrl</span><span class="c0">.</span><span class="c3 c6">valueChanges</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; </span><span class="c0">.</span><span class="c3">debounceTime</span><span class="c0">(</span><span class="c11">500</span><span class="c0">)</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; </span><span class="c0">.</span><span class="c3">mapTo</span><span class="c0">(</span><span class="c14">this</span><span class="c0">.</span><span class="c3">ctrl</span><span class="c0">)</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; </span><span class="c0">.</span><span class="c3">switchMap</span><span class="c0">(</span><span class="c14">this</span><span class="c0">.</span><span class="c3">myAsyncValidator</span><span class="c0">.</span><span class="c3">bind</span><span class="c0">(</span><span class="c14">this</span><span class="c0">))</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; </span><span class="c0">.</span><span class="c3">subscribe</span><span class="c0">(</span><span class="c14">this</span><span class="c0">.</span><span class="c3">ctrl</span><span class="c0">.</span><span class="c3">setErrors</span><span class="c0">);</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c0">});</span></p><p class="c2"><span class="c0">}</span></p></td></tr></tbody></table><p class="c9"><span class="c4">This does work. It will only call the async validator after the debounce period and the errors will be set. There are currently a few issues with this pattern:</span></p><ol class="c33 lst-kix_43vsgntzcupx-0 start" start="1"><li class="c9 c19"><span class="c29">myAsyncValidator</span><span class="c5 c4">&nbsp;will be run whether or not sync validators pass. Normally, async validators only run if sync validators return a VALID status. So in this case, any errors from sync validators will be overwritten by the async validator when it comes back. </span></li><li class="c9 c19"><span class="c5 c4">Because the normal validator infrastructure isn&#39;t utilized, we can&#39;t know that this async validation is happening and can&#39;t correctly report the status as &#39;PENDING&#39; while waiting for a response from the validator. It will only report a validation status based on the validators that were explicitly passed in (thus, it will always report VALID during the debounce period). &nbsp;</span></li></ol><p class="c9"><span class="c4">Some developers have also </span><span class="c16 c4"><a class="c15" href="https://www.google.com/url?q=https://github.com/angular/angular/issues/6895%23issuecomment-215704334&amp;sa=D&amp;ust=1514893617363000&amp;usg=AFQjCNGY-Q6BHXHGj7d6LBqJvZj17vFjiQ">created a &quot;debounced&quot; control value accessor</a></span><span class="c5 c4">&nbsp;to override the default accessor, so that only debounced value changes are actually passed up to form directives. This solution prevents validation from running until the debounce period has passed, but also prevents the model from being updated at all during that time. Apart from that, the implementation is quite a bit of work for a simple debounce. Any application that wanted to debounce different types of form controls would still have to implement an entire control value accessor for each control type - select, multi-select, checkboxes, etc. It&#39;s not a sustainable pattern.</span></p><p class="c9"><span class="c5 c4">The use of these workarounds outside the normal workflow implies that these are shortcomings that should be addressed at the framework level. We should support debouncing expensive validators. We should also support limiting validation runs based on other popular constraints, like whether or not the control has been touched.</span></p><p class="c9"><span class="c5 c4">See related issues:</span></p><p class="c9"><span class="c16 c4"><a class="c15" href="https://www.google.com/url?q=https://github.com/angular/angular/issues/6895&amp;sa=D&amp;ust=1514893617364000&amp;usg=AFQjCNH7jL6oiHD02eG7KKgJlQILgUrbjw">https://github.com/angular/angular/issues/6895</a></span></p><p class="c9"><span class="c16 c4"><a class="c15" href="https://www.google.com/url?q=https://github.com/angular/angular/issues/7113&amp;sa=D&amp;ust=1514893617364000&amp;usg=AFQjCNHz3vzkplY-KTg23vwKg99lN_XY6g">https://github.com/angular/angular/issues/7113</a></span><span class="c5 c4">&nbsp;</span></p><a id="kix.ealz8zgg8rht"></a><p class="c9"><span class="c37 c4">Problem 2: Debouncing control-based styles</span></p><p class="c9"><span class="c5 c4">Let&#39;s say you want your text field to turn green when the input is valid and turn red when it&#39;s invalid, but you want to give your users a few moments to finish typing before applying the background. In other words, you&#39;d want error styles to appear on a debounce. </span></p><p class="c9"><span class="c5 c4">Unlike with &quot;touched&quot; or &quot;dirty&quot;, there&#39;s no control property for &quot;debounced&quot; that can be used to toggle the style. The built-in control status classes - ng-valid, ng-pending, etc - are applied immediately, so they aren&#39;t usable on their own. </span></p><p class="c9"><span class="c5 c4">With the current setup, the best way to make this work is to skip our built-in classes and create your own control status classes. You&#39;d then have to apply them manually after subscribing to and debouncing validation status changes yourself. This is a lot of work for a fairly common use case.</span></p><p class="c9"><span class="c4">See related issue: </span><span class="c16 c4"><a class="c15" href="https://www.google.com/url?q=https://github.com/angular/angular/issues/13920&amp;sa=D&amp;ust=1514893617365000&amp;usg=AFQjCNFiyUS_vdSuoz8UllLh_gQawQzp8Q">https://github.com/angular/angular/issues/13920</a></span><span class="c4 c5">&nbsp;</span></p><p class="c9"><span class="c51 c4">Problem 3: Observables must complete to set errors</span></p><p class="c9"><span class="c4">Currently, we </span><span class="c4">require all observables provided by async validators to complete </span><span class="c5 c4">before setting the errors. Originally, we only supported Promises in async validators, so when we added observables, we just plugged them into the existing infrastructure (which expected one value).</span></p><p class="c9"><span class="c5 c4">The problem is simply emitting a value has no effect and will not set validation status or errors. Requiring this is a huge &quot;gotcha&quot; for developers because validation will silently stick at PENDING forever if the observable fails to complete. </span></p><p class="c9"><span class="c4">It also makes real-time validation difficult. Using </span><span class="c29">http.get</span><span class="c4">, you can &ldquo;pull&rdquo; a validation result when the value changes, but if there are future updates, you won&rsquo;t receive them until the value changes again. If you were using something like AngularFire and had a </span><span class="c29">FirebaseListObservable</span><span class="c4">, new data would be emitted once it was available. However, our current pipeline cannot take advantage of subsequent updates because it requires observable validators to complete. You would have to subscribe separately and call </span><span class="c29">updateValueAndValidity</span><span class="c5 c4">() manually when new data came in.</span></p><p class="c9"><span class="c6 c4 c39">Prior art: AngularJS</span></p><p class="c2 c12"><span class="c5 c4"></span></p><p class="c2 c25"><span class="c5 c4">AngularJS links error types with specific validation statuses:</span></p><p class="c2 c12"><span class="c5 c4"></span></p><ul class="c33 lst-kix_fms7lhkslz59-0 start"><li class="c2 c25 c19"><span class="c5 c4">Error map ---&gt; &nbsp;INVALID</span></li><li class="c2 c25 c19"><span class="c5 c4">Null ---&gt; VALID</span></li><li class="c2 c25 c19"><span class="c5 c4">Undefined &nbsp;---&gt; PENDING</span></li></ul><p class="c2 c12"><span class="c5 c4"></span></p><p class="c2 c25"><span class="c5 c4">In other words, you can derive validation status from the errors property and vice versa. &nbsp;</span></p><p class="c2 c12"><span class="c5 c4"></span></p><p class="c2 c25"><span class="c5 c4">We have something similar in Angular:</span></p><p class="c2 c12"><span class="c5 c4"></span></p><ul class="c33 lst-kix_xhvwz2h9vhlu-0 start"><li class="c2 c25 c19"><span class="c5 c4">Error map ---&gt; &nbsp;INVALID</span></li><li class="c2 c25 c19"><span class="c5 c4">Null ---&gt; VALID / PENDING</span></li></ul><p class="c2 c12"><span class="c5 c4"></span></p><p class="c2 c25"><span class="c4">But it is less deterministic, as </span><span class="c29">null</span><span class="c5 c4">&nbsp;could imply either VALID or PENDING.</span></p><p class="c2 c12"><span class="c5 c4"></span></p><p class="c2 c25"><span class="c4">AngularJS also provides an easy way to control the timing of validation runs with the </span><span class="c29">debounce</span><span class="c4">&nbsp;and </span><span class="c29">updateOn</span><span class="c4">&nbsp;properties in </span><span class="c29">ng-model-options</span><span class="c5 c4">.</span></p><p class="c2 c12"><span class="c5 c4"></span></p><a id="t.128799131c8aba8b00f1b7b516b503217533d0ce"></a><a id="t.7"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c21">&lt;input</span><span class="c3">&nbsp;ng-model</span><span class="c0">=</span><span class="c3">&quot;name&quot; ng-model-options</span><span class="c0">=</span><span class="c3">&quot;{debounce: 500}&quot;</span><span class="c21">&gt;</span></p><p class="c2 c28"><span class="c3 c6"></span></p><p class="c2"><span class="c21">&lt;input</span><span class="c3">&nbsp;ng-model</span><span class="c0">=</span><span class="c3">&quot;name&quot; ng-model-options</span><span class="c0">=</span><span class="c3">&quot;{updateOn: &#39;mousedown blur&#39;}&quot;</span><span class="c21">&gt;</span></p></td></tr></tbody></table><p class="c2 c12"><span class="c5 c7"></span></p><p class="c2 c25"><span class="c4">Interestingly, it supports updating on both blur </span><span class="c4 c32">and</span><span class="c5 c4">&nbsp;on a debounce. If you provide both options, the debounce timer won&#39;t start until the blur event has happened.</span></p><p class="c2 c12"><span class="c5 c4"></span></p><p class="c2 c25"><span class="c5 c4">Rather than just gating validation, these options block any updates of the model value until the condition passes. This seems to preclude the case where an app might want to receive value updates immediately (perhaps the content is displaying elsewhere in the UI as you type), but also rate limit costly validation.</span></p><p class="c2 c12"><span class="c5 c4"></span></p><p class="c2 c25"><span class="c5 c4">However, requiring that value and validation updates always run together does guarantee that the validation status will always match the value. If one simply delays running validation, there are times where values and validation statuses aren&#39;t in sync and statuses become stale.</span></p><p class="c2 c12"><span class="c5 c4"></span></p><p class="c2 c25"><span class="c4">See: </span><span class="c16 c4"><a class="c15" href="https://www.google.com/url?q=https://docs.angularjs.org/guide/forms&amp;sa=D&amp;ust=1514893617369000&amp;usg=AFQjCNHzB-h6YuayR_OYaKF-yCo_c1yq2g">AngularJS forms docs</a></span><span class="c4">, </span><span class="c16 c4"><a class="c15" href="https://www.google.com/url?q=https://plnkr.co/edit/ffDqgGrwhVqAZyB4lQfw?p%3Dpreview&amp;sa=D&amp;ust=1514893617369000&amp;usg=AFQjCNElTqXC0KePptBunmIpYMKp8yukGQ">AngularJS debouncing example</a></span></p><p class="c2 c12"><span class="c5 c7"></span></p><h1 class="c30" id="h.gijrsdjw51q5"><span class="c4 c42">Detailed Design</span></h1><a id="id.7pewh9ce3j08"></a><h3 class="c9 c36" id="h.r6gn0i8f19wz"><span class="c51 c7 c57">Proposed API</span></h3><p class="c9"><span class="c5 c4">The goal is to give developers more power over their validation pipelines without adding undue complexity or requiring them to re-learn validation.</span></p><p class="c9"><span class="c5 c4">With this end in mind, it makes sense to keep the original validation API around, but offer developers the option to hook into a more customizable, low-level system if their applications require it. &nbsp;You can think of it as two tracks: simple (most use cases) and advanced (high customization required).</span></p><p class="c9"><span class="c5 c23">Simple track</span></p><p class="c9"><span class="c4">In template-driven forms, developers can define a debounce property in the existing </span><span class="c29">ngModelOptions</span><span class="c5 c4">&nbsp;config.</span></p><a id="t.752b0a46edc91952bf49ad9171eb72ba6ab0de02"></a><a id="t.8"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c21">&lt;input</span><span class="c3">&nbsp;[(ngModel)]</span><span class="c0">=</span><span class="c3">&quot;name&quot; [ngModelOptions]</span><span class="c0">=</span><span class="c3">&quot;{</span><span class="c3">debounce: 500}</span><span class="c3">&quot; required</span><span class="c21">&gt;</span></p></td></tr></tbody></table><p class="c9"><span class="c5 c4">Like AngularJS, both value and validity updates will be gated behind this debounce period. Always updating value and validity together helps keep the process simple for people to reason about because value and validation status will always stay in sync. </span></p><p class="c9"><span class="c5 c4">Otherwise, if we just debounce validation, there would be 500ms where the value would be &quot;abc&quot; but the validation status would still be INVALID. Similarly, there would be 500ms between when the control became dirty and when validation runs, so this could potentially mess up error messages gated on dirtiness.</span></p><p class="c9"><span class="c5 c4">It&#39;s also easier to predict how other properties are affected. If you think of it as the whole forms pipeline does not run again until &quot;debounce&quot;, then you can already guess that &quot;dirty&quot; and other properties will also not be updated.</span></p><p class="c9"><span class="c4">The above line of code would be sufficient to solve two of the problems described in the previous section: debouncing expensive validators (</span><span class="c16 c4"><a class="c15" href="#kix.ohyn6trawk0t">problem 1</a></span><span class="c4">) and allowing the application of debounced error styling (</span><span class="c16 c4"><a class="c15" href="#kix.ealz8zgg8rht">problem 2</a></span><span class="c5 c4">). </span></p><p class="c9"><span class="c4">For the common use case of updating on blur, we can also offer an </span><span class="c29">updateOn</span><span class="c5 c4">&nbsp;option.</span></p><a id="t.15711a7e9ade54ec80044f9894de014c0dd8f905"></a><a id="t.9"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c21">&lt;input</span><span class="c3">&nbsp;[(ngModel)]</span><span class="c0">=</span><span class="c3">&quot;name&quot; [ngModelOptions]</span><span class="c0">=</span><span class="c3">&quot;{updateOn: </span><span class="c43">&#39;</span><span class="c49">blur</span><span class="c43">&#39;</span><span class="c3">}&quot; required</span><span class="c21">&gt;</span></p></td></tr></tbody></table><p class="c9 c28"><span class="c5 c4"></span></p><p class="c9"><span class="c4">Potential values for </span><span class="c29">updateOn</span><span class="c5 c4">:</span></p><p class="c9"><span class="c5 c4">Event-based:</span></p><ul class="c33 lst-kix_gnv4opshje3l-0 start"><li class="c9 c19"><span class="c23">&lsquo;change&rsquo;</span><span class="c5 c4">&nbsp;(default) - updates occur when the value changes</span></li><li class="c9 c19"><span class="c23">&lsquo;blur&rsquo; -</span><span class="c5 c4">&nbsp;updates occur every time the field is blurred</span></li><li class="c9 c19"><span class="c23">&lsquo;submit&rsquo; - </span><span class="c5 c4">updates occur every time the parent form is submitted</span></li></ul><p class="c9"><span class="c5 c4">Property-based (Angular Material-style):</span></p><ul class="c33 lst-kix_gnv4opshje3l-0"><li class="c9 c19"><span class="c23">&lsquo;touched&rsquo; </span><span class="c5 c4">&nbsp;- updates occur once the control&rsquo;s touched property is true. After the first &ldquo;blur&rdquo; event, the control will always be touched, so updates then occur on every value change.</span></li><li class="c9 c19"><span class="c23">&lsquo;submitted&rsquo;</span><span class="c4">&nbsp;- updates occur once the parent form&rsquo;s submitted property is true. After the first &ldquo;submit&rdquo; event, the form will always be submitted, so updates then occur on every value change.</span></li></ul><p class="c9"><span class="c4">For both </span><span class="c29">debounce</span><span class="c4">&nbsp;and </span><span class="c29">updateOn,</span><span class="c5 c4">&nbsp;the similarity of the semantics to AngularJS will likely appeal to developers who are accustomed to AngularJS and will facilitate upgrading those applications to Angular.</span></p><p class="c9"><span class="c4">On the reactive forms side, we can add a corresponding options argument that takes the same options: </span><span class="c29">debounce</span><span class="c4">&nbsp;and </span><span class="c29">updateOn</span><span class="c5 c4">. </span></p><a id="t.107d9fc0500a57403e03813afe108aa2834c8814"></a><a id="t.10"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c3">ctrl </span><span class="c0">=</span><span class="c3">&nbsp;</span><span class="c14">new</span><span class="c3">&nbsp;</span><span class="c17">FormControl</span><span class="c0">(</span><span class="c43">&#39;&#39;</span><span class="c0">,</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;debounce</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c11">1000</span><span class="c0">,</span><span class="c3 c6">&nbsp;</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c3">validators</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c0">[</span><span class="c17">Validators</span><span class="c0">.</span><span class="c3">required</span><span class="c0">]</span></p><p class="c2"><span class="c0">});</span><span class="c3">&nbsp;</span></p></td></tr></tbody></table><p class="c9"><span class="c4">To avoid the inconvenience of </span><span class="c29">null</span><span class="c5 c4">&nbsp;arguments for validators and async validators, one can optionally pass the options argument in as the second argument instead of validators (and simply pass validators in as an option).</span></p><p class="c9"><span class="c4">As this is the simple track, we want syntax that is usable for developers who are new to reactive programming. There are many using reactive forms that won&#39;t want to figure out how to define an entire validation stream, so this fallback is convenient for the </span><span class="c29">ReactiveFormsModule</span><span class="c5 c4">&nbsp;as well. &nbsp;</span></p><p class="c9"><span class="c5 c4">Separating the debounce argument into an option also makes it clear that this is a global debounce that will apply to the whole validation chain of this control, not just one validator.</span></p><p class="c9"><span class="c4">Note: If both </span><span class="c29">debounce</span><span class="c4">&nbsp;and </span><span class="c29">updateOn</span><span class="c4">&nbsp;options are provided, we should probably favor the more restrictive, </span><span class="c29">updateOn</span><span class="c4">. &nbsp;Another possibility would be to collapse them into one </span><span class="c29">updateOn</span><span class="c5 c4">&nbsp;option, where a number value always implies a debounce period.</span></p><p class="c9"><span class="c5 c4">For large applications, editing each form control&#39;s validation timing individually would be onerous. For these cases, we could also accept validation timing options on a FormGroup and FormArray basis.</span></p><a id="t.584141b254121c2e45237b9ff8896daafdb599e6"></a><a id="t.11"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c3">form </span><span class="c0">=</span><span class="c3">&nbsp;</span><span class="c14">new</span><span class="c3">&nbsp;</span><span class="c17">FormGroup</span><span class="c0">({</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;login</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c14">new</span><span class="c3">&nbsp;</span><span class="c17">FormControl</span><span class="c0">(</span><span class="c43">&#39;&#39;</span><span class="c0">,</span><span class="c3">&nbsp;</span><span class="c17">Validators</span><span class="c0">.</span><span class="c3">required</span><span class="c0">)</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;password</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c14">new</span><span class="c3">&nbsp;</span><span class="c17">FormControl</span><span class="c0">(</span><span class="c43">&#39;&#39;</span><span class="c0">,</span><span class="c3">&nbsp;</span><span class="c17">Validators</span><span class="c0">.</span><span class="c3">required</span><span class="c0">)</span></p><p class="c2"><span class="c0">},</span><span class="c3">&nbsp;</span><span class="c0">{</span><span class="c3">&nbsp;updateOn</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c43">&lsquo;submit&rsquo;</span><span class="c3">&nbsp;</span><span class="c0">});</span></p></td></tr></tbody></table><p class="c9"><span class="c5 c4">Or we could expand to application-wide / &nbsp;module-wide controls with a provider.</span></p><a id="t.11053e693d4c35c46eef7f0fdf31b16a55777fc5"></a><a id="t.12"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c0">{</span><span class="c3">provide</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c49">FORM_UPDATE</span><span class="c3">_</span><span class="c49">OPTIONS</span><span class="c0">,</span><span class="c3">&nbsp;useValue</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c0">{</span><span class="c3">updateOn</span><span class="c0">:</span><span class="c3">&nbsp; </span><span class="c43">&lsquo;blur&rsquo;</span><span class="c0">}}</span></p></td></tr></tbody></table><p class="c9 c28"><span class="c5 c23"></span></p><p class="c9"><span class="c23">Advanced track</span></p><p class="c9"><span class="c5 c4">For developers that are more experienced with reactive programming and/or have more unique use cases, we can give them the ability to hook into our validation pipeline directly.</span></p><p class="c9"><span class="c4">How will this work? Let&#39;s say instead of a callback-based structure, we have a stream of value changes internally (more on that in the </span><span class="c16 c4"><a class="c15" href="#h.m5fkictb5ysp">implementation section</a></span><span class="c5 c4">). We would map this stream through our validator list to get a list of errors (or null), then use those errors to calculate the validation status of the tree.</span></p><a id="t.e5e945a0fd49beb9892a1b6d95ff362152cfcc46"></a><a id="t.13"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c17">Value</span><span class="c3">&nbsp;changes &nbsp;</span><span class="c0">----&gt;</span><span class="c3">&nbsp;map</span><span class="c0">(</span><span class="c3">validators</span><span class="c0">)</span><span class="c3">&nbsp;</span><span class="c0">---&gt;</span><span class="c3">&nbsp; setErrors</span><span class="c0">(</span><span class="c3">errs</span><span class="c0">)</span><span class="c3">&nbsp;</span><span class="c0">--&gt;</span><span class="c3">&nbsp;calculateStatus</span></p></td></tr></tbody></table><p class="c9"><span class="c4">The validation status is always calculated from the control&#39;s errors (and its children&#39;s errors, if it has any). &nbsp;If the </span><span class="c29">errors</span><span class="c5 c4">&nbsp;property is a map of errors, the status is calculated to be INVALID. If null, the status is calculated to be VALID.</span></p><p class="c9"><span class="c4">Additionally, we should add a third mapping such that returning a </span><span class="c29">PENDING</span><span class="c4">&nbsp;token will set the status as PENDING. This way, we have three clearly deterministic mappings from errors to status. This pending token could be of type </span><span class="c29">ValidationErrors</span><span class="c4">&nbsp;(something like </span><span class="c29">{pending: true}</span><span class="c5 c4">).</span></p><p class="c9"><span class="c4">In code, our default validation chain would look something like this </span><span class="c16 c4"><a class="c15" href="#kix.qmphd6n73t19">*</a></span><span class="c5 c4">:</span></p><a id="t.af976a75dce8777b3133c15b0379a118d0a78607"></a><a id="t.14"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c3">&nbsp;obs</span><span class="c0">.</span><span class="c3">map</span><span class="c0">(</span><span class="c14">this</span><span class="c0">.</span><span class="c3">validator</span><span class="c0">)</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; </span><span class="c0">.</span><span class="c3">switchMap</span><span class="c0">((</span><span class="c3">errs</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c17">ValidationErrors</span><span class="c0">|</span><span class="c14">null</span><span class="c0">)</span><span class="c3">&nbsp;</span><span class="c0">=&gt;</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c14">return</span><span class="c3">&nbsp;errs </span><span class="c0">||</span><span class="c3">&nbsp;</span><span class="c0">!</span><span class="c14">this</span><span class="c0">.</span><span class="c3 c6">asyncValidator </span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">?</span><span class="c3">&nbsp;</span><span class="c17">Observable</span><span class="c0">.</span><span class="c3">of</span><span class="c0">(</span><span class="c3">errs</span><span class="c0">)</span><span class="c3 c6">&nbsp;</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c14">this</span><span class="c0">.</span><span class="c3">asyncValidator</span><span class="c0">(</span><span class="c14">this</span><span class="c0">).</span><span class="c3">startWith</span><span class="c0">(</span><span class="c3">PENDING</span><span class="c0">);</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; </span><span class="c0">})</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; </span><span class="c0">.</span><span class="c3">map</span><span class="c0">(</span><span class="c14">this</span><span class="c0">.</span><span class="c3">setErrors</span><span class="c0 c6">);</span></p></td></tr></tbody></table><p class="c9"><span class="c5 c4">Summary of above:</span></p><ol class="c33 lst-kix_16ua50byh6-0 start" start="1"><li class="c9 c19"><span class="c4">First, the control gets passed through the sync validators (which have already been composed into the aggregate function, </span><span class="c29">this.validator</span><span class="c5 c4">).</span></li><li class="c9 c19"><span class="c5 c4">If there are errors or there aren&#39;t any async validators, switchMap to an observable that will emit the errors immediately and complete. Otherwise, switch to subscribe to the observable returned by the async validator.</span></li><li class="c9 c19"><span class="c4">Due to the </span><span class="c29">startWith</span><span class="c4">&nbsp;operator, the errors object will be set to the </span><span class="c29">PENDING</span><span class="c5 c4">&nbsp;token immediately, which in turn sets the status to PENDING.</span></li><li class="c9 c19"><span class="c5 c4">Once the async validator emits a value, the errors will be set to that value, which will translate into a VALID or INVALID status.</span></li></ol><p class="c9"><span class="c4 c18">*</span><a id="kix.qmphd6n73t19"></a><span class="c4 c18">Note: In the real codebase, we won&#39;t be able to chain operators directly because we should avoid global imports like </span><span class="c29 c32">import &#39;rxjs/add/operator/switchMap&#39;</span><span class="c4 c18">. &nbsp;Instead, we&#39;ll just import the operator functions we need and use the </span><span class="c29 c32">call()</span><span class="c44 c4 c18">&nbsp;syntax. &nbsp;However, in the interest of keeping the code easily readable, the examples will use chaining syntax.</span></p><p class="c9"><span class="c4">So where does the customization come in? If we want to give developers the ability to define their own validation pipeline, we&#39;d want them to replace the </span><span class="c29">map</span><span class="c4">&nbsp;and </span><span class="c29">switchMap</span><span class="c5 c4">&nbsp;blocks:</span></p><a id="t.07f0ff34edaca6f63ec8c566d86a6a6862516761"></a><a id="t.15"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c3 c6">valueChanges</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c47">// user defines this part of the chain</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c0">.</span><span class="c3">subscribe</span><span class="c0">(</span><span class="c3">errors </span><span class="c0">=&gt;</span><span class="c3">&nbsp;</span><span class="c14">this</span><span class="c0">.</span><span class="c3">setErrors</span><span class="c0">(</span><span class="c3">errors</span><span class="c0">));</span></p></td></tr></tbody></table><p class="c9"><span class="c4">In other words, they would need to be able to define a chunk of the chain. To do so, they&#39;d require a reference to the source observable, so they can transform it and return the result to the chain. This is where the </span><span class="c29">let</span><span class="c5 c4">&nbsp;operator comes in.</span></p><a id="t.ca7d1fd454b0014cc1cfcb076ce3482740651b21"></a><a id="t.16"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c3 c6">valueChanges</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c0">.</span><span class="c3">let</span><span class="c0">((</span><span class="c3">obs</span><span class="c0">)</span><span class="c3">&nbsp;</span><span class="c0">=&gt;</span><span class="c3">&nbsp;obs</span><span class="c0">.</span><span class="c3">map</span><span class="c0">(</span><span class="c3">validators</span><span class="c0">))</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c0">.</span><span class="c3">subscribe</span><span class="c0">(</span><span class="c3">errors </span><span class="c0">=&gt;</span><span class="c3">&nbsp;</span><span class="c14">this</span><span class="c0">.</span><span class="c3">setErrors</span><span class="c0">(</span><span class="c3">errors</span><span class="c0">));</span></p></td></tr></tbody></table><p class="c9"><span class="c29">let</span><span class="c5 c4">&nbsp;allows you to apply reusable middleware within an observable chain. It takes a selector function that receives the source observable as its argument. You can then apply any operators to that observable within the function and the returned observable is flattened back into the original chain. </span></p><p class="c9"><span class="c4">In practice, this means we can allow developers to define selector functions (or, </span><span class="c29">ValidatorChains</span><span class="c4">, as we might call them) in addition to validators and async validators. Then we can just plug the functions into the </span><span class="c29">let</span><span class="c5 c4">&nbsp;part of our internal chain when appropriate.</span></p><p class="c9"><span class="c6 c4 c27">What developer writes:</span></p><a id="t.0124381692da3093fee3ee634a8698a07a6bae62"></a><a id="t.17"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c3">ctrl </span><span class="c0">=</span><span class="c3">&nbsp;</span><span class="c14">new</span><span class="c3">&nbsp;</span><span class="c17">FormControl</span><span class="c0">(</span><span class="c43">&#39;&#39;</span><span class="c0">,</span><span class="c3">&nbsp;</span><span class="c0">{</span><span class="c3">validatorChain</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c14">this</span><span class="c0">.</span><span class="c3">myChain</span><span class="c0">});</span></p><p class="c2"><span class="c0">...</span></p><p class="c2 c28"><span class="c3 c6"></span></p><p class="c2"><span class="c3">myChain</span><span class="c0">(</span><span class="c3">ctrl</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c17">AbstractControl</span><span class="c0">):</span><span class="c3">&nbsp;</span><span class="c17">ValidatorChain</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c14">return</span><span class="c3">&nbsp;</span><span class="c0">(</span><span class="c3">obs</span><span class="c0">)</span><span class="c3">&nbsp;</span><span class="c0">=&gt;</span><span class="c3">&nbsp;obs</span><span class="c0">.</span><span class="c3">map</span><span class="c0">(</span><span class="c17">Validators</span><span class="c0">.</span><span class="c3">required</span><span class="c0">);</span></p><p class="c2"><span class="c0">}</span></p></td></tr></tbody></table><p class="c9"><span class="c6 c4 c27">Internal forms code (simplified):</span></p><a id="t.73541886dfea8f0a89354fb93d010da44d43a61f"></a><a id="t.18"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c3 c6">valueChanges</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c0">.</span><span class="c3">let</span><span class="c0">(</span><span class="c14">this</span><span class="c0">.</span><span class="c3">validatorChain</span><span class="c0">(</span><span class="c14">this</span><span class="c0">))</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c0">.</span><span class="c3">subscribe</span><span class="c0">(</span><span class="c3">errors </span><span class="c0">=&gt;</span><span class="c3">&nbsp;</span><span class="c14">this</span><span class="c0">.</span><span class="c3">setErrors</span><span class="c0">(</span><span class="c3">errors</span><span class="c0">));</span></p></td></tr></tbody></table><p class="c9"><span class="c5 c4">In the real implementation, we also need to support default validation behavior if a chain is not passed in, so we&#39;d end up wrapping it. If we separate out the default validation chain into an exported function, developers can also reuse it in their own chains where it makes sense.</span></p><p class="c9"><span class="c4 c53">Internal forms code:</span></p><a id="t.44cd09010ee9d4d814d043bbae37d151c25d7983"></a><a id="t.19"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c3 c6">valueChanges</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c0">.</span><span class="c3">let</span><span class="c0">((</span><span class="c3">obs</span><span class="c0">)</span><span class="c3">&nbsp;</span><span class="c0">=&gt;</span><span class="c3">&nbsp;</span><span class="c14">this</span><span class="c0">.</span><span class="c3">chain </span><span class="c0">?</span><span class="c3">&nbsp;</span><span class="c14">this</span><span class="c0">.</span><span class="c3">chain</span><span class="c0">(</span><span class="c14">this</span><span class="c0">)(</span><span class="c3">obs</span><span class="c0">)</span><span class="c3">&nbsp;</span><span class="c0">:</span><span class="c3">&nbsp;defaultChain</span><span class="c0">(</span><span class="c14">this</span><span class="c0">)(</span><span class="c3">obs</span><span class="c0">))</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c0">.</span><span class="c3">subscribe</span><span class="c0">(</span><span class="c3">errors </span><span class="c0">=&gt;</span><span class="c3">&nbsp;</span><span class="c14">this</span><span class="c0">.</span><span class="c3">setErrors</span><span class="c0">(</span><span class="c3">errors</span><span class="c0">));</span></p><p class="c2 c28"><span class="c3 c6"></span></p><p class="c2 c28"><span class="c3 c6"></span></p><p class="c2"><span class="c14">function</span><span class="c3">&nbsp;defaultChain</span><span class="c0">(</span><span class="c3">ctrl</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c17">AbstractControl</span><span class="c0">):</span><span class="c3">&nbsp;</span><span class="c17">ValidatorChain</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c14">return</span><span class="c3">&nbsp;</span><span class="c0">(</span><span class="c3">obs</span><span class="c0">)</span><span class="c3">&nbsp;</span><span class="c0">=&gt;</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; </span><span class="c14">return</span><span class="c3">&nbsp;obs</span><span class="c0">.</span><span class="c3">map</span><span class="c0">(</span><span class="c3">ctrl</span><span class="c0">.</span><span class="c3">validator</span><span class="c0">)</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">.</span><span class="c3">switchMap</span><span class="c0">(</span><span class="c3">errs </span><span class="c0">=&gt;</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c14">return</span><span class="c3">&nbsp;errs </span><span class="c0">||</span><span class="c3">&nbsp;</span><span class="c0">!</span><span class="c3">ctrl</span><span class="c0">.</span><span class="c3 c6">asyncValidator </span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">?</span><span class="c3">&nbsp;</span><span class="c17">Observable</span><span class="c0">.</span><span class="c3">of</span><span class="c0">(</span><span class="c3">errs</span><span class="c0">)</span><span class="c3 c6">&nbsp;</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">:</span><span class="c3">&nbsp;ctrl</span><span class="c0">.</span><span class="c3">asyncValidator</span><span class="c0">(</span><span class="c3">ctrl</span><span class="c0">).</span><span class="c3">startWith</span><span class="c0">(</span><span class="c3">PENDING</span><span class="c0">);</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">});</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c0">};</span></p><p class="c2"><span class="c0">}</span></p></td></tr></tbody></table><p class="c9"><span class="c5 c4">So what does this feature empower developers to do? </span></p><p class="c9"><span class="c4">Because they own the control&#39;s validation chain start to finish, they can customize its execution </span><span class="c4 c32">any</span><span class="c5 c4">&nbsp;way they like. Through the error values their chain emits, developers have full control over when and how validation statuses are set, and they can emit as often or as infrequently as makes sense for their application. This pattern is also fairly expressive because at a glance, one can understand the full validation lifecycle of each control.</span></p><p class="c9"><span class="c5 c4">With chains, we can create both simple and complex validation pipelines. Let&#39;s start with simple examples that recreate what you can do with the default pipeline, then we can add customizations.</span></p><p class="c9"><span class="c6 c4 c27">One sync validator</span></p><a id="t.c79f401bd73db5180c84cb25b62d1e9da14cf684"></a><a id="t.20"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c3">myChain</span><span class="c0">(</span><span class="c3">ctrl</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c17">AbstractControl</span><span class="c0">):</span><span class="c3">&nbsp;</span><span class="c17">ValidatorChain</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c14">return</span><span class="c3">&nbsp;</span><span class="c0">(</span><span class="c3">obs</span><span class="c0">)</span><span class="c3">&nbsp;</span><span class="c0">=&gt;</span><span class="c3">&nbsp;obs</span><span class="c0">.</span><span class="c3">map</span><span class="c0">(</span><span class="c17">Validators</span><span class="c0">.</span><span class="c3">required</span><span class="c0">);</span></p><p class="c2"><span class="c0">}</span></p></td></tr></tbody></table><p class="c9"><span class="c6 c4 c27">Multiple sync validators</span></p><a id="t.3c05501d702373f19be9e78005d9db84ff909fa6"></a><a id="t.21"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c3">myChain</span><span class="c0">(</span><span class="c3">ctrl</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c17">AbstractControl</span><span class="c0">):</span><span class="c3">&nbsp;</span><span class="c17">ValidatorChain</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c14">return</span><span class="c3">&nbsp;</span><span class="c0">(</span><span class="c3">obs</span><span class="c0">)</span><span class="c3">&nbsp;</span><span class="c0">=&gt;</span><span class="c3">&nbsp;obs</span><span class="c0">.</span><span class="c3">map</span><span class="c0">(</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; </span><span class="c17">Validators</span><span class="c0">.</span><span class="c3">compose</span><span class="c0">([</span><span class="c17">Validators</span><span class="c0">.</span><span class="c3">required</span><span class="c0">,</span><span class="c3">&nbsp;</span><span class="c17">Validators</span><span class="c0">.</span><span class="c3">minLength</span><span class="c0">(</span><span class="c11">3</span><span class="c0">)])</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c0">);</span></p><p class="c2"><span class="c0">}</span></p></td></tr></tbody></table><p class="c9"><span class="c5 c4">The built-in composition function above is handy to merge errors, but it&#39;s worth noting developers can also roll their own based on their app&#39;s specifications.</span></p><p class="c9"><span class="c6 c4 c27">Multiple async validators</span></p><a id="t.e436e904a911e96e364954bc0fafba0e248aa944"></a><a id="t.22"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c3">myChain</span><span class="c0">(</span><span class="c3">ctrl</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c17">AbstractControl</span><span class="c0">):</span><span class="c3">&nbsp;</span><span class="c17">ValidatorChain</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c14">return</span><span class="c3">&nbsp;</span><span class="c0">(</span><span class="c3">obs</span><span class="c0">)</span><span class="c3">&nbsp;</span><span class="c0">=&gt;</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; </span><span class="c14">return</span><span class="c3 c6">&nbsp;obs</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">.</span><span class="c3">map</span><span class="c0">(</span><span class="c17">Validators</span><span class="c0">.</span><span class="c3">required</span><span class="c0">)</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">.</span><span class="c3">switchMap</span><span class="c0">(</span><span class="c3">errs </span><span class="c0">=&gt;</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c14">return</span><span class="c3">&nbsp;errs </span><span class="c0">?</span><span class="c3">&nbsp;</span><span class="c17">Observable</span><span class="c0">.</span><span class="c3">of</span><span class="c0">(</span><span class="c3">errs</span><span class="c0">)</span><span class="c3 c6">&nbsp;</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c14">this</span><span class="c0">.</span><span class="c3">asyncValidators</span><span class="c0">.</span><span class="c3">startWith</span><span class="c0">(</span><span class="c3">PENDING</span><span class="c0">);</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">});</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c0">};</span></p><p class="c2"><span class="c0">}</span></p><p class="c2 c28"><span class="c3 c6"></span></p><p class="c2"><span class="c14">get</span><span class="c3">&nbsp;asyncValidators</span><span class="c0">()</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c14">return</span><span class="c3">&nbsp;</span><span class="c17">Validators</span><span class="c0">.</span><span class="c3">composeAsync</span><span class="c0">([</span><span class="c14">this</span><span class="c0">.</span><span class="c3">userValidator</span><span class="c0">,</span><span class="c3">&nbsp;</span><span class="c14">this</span><span class="c0">.</span><span class="c3">otherValidator</span><span class="c0">]);</span></p><p class="c2"><span class="c0">}</span></p></td></tr></tbody></table><p class="c9"><span class="c6 c4 c27">Multiple async validators + custom composition</span></p><a id="t.72ee4e4d96aa8157cc281eb3a73d83961401df16"></a><a id="t.23"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c3">myChain</span><span class="c0">(</span><span class="c3">ctrl</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c17">AbstractControl</span><span class="c0">):</span><span class="c3">&nbsp;</span><span class="c17">ValidatorChain</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c14">return</span><span class="c3">&nbsp;</span><span class="c0">(</span><span class="c3">obs</span><span class="c0">)</span><span class="c3">&nbsp;</span><span class="c0">=&gt;</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; </span><span class="c14">return</span><span class="c3 c6">&nbsp;obs</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">.</span><span class="c3">map</span><span class="c0">(</span><span class="c17">Validators</span><span class="c0">.</span><span class="c3">required</span><span class="c0">)</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">.</span><span class="c3">switchMap</span><span class="c0">(</span><span class="c3">errs </span><span class="c0">=&gt;</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c14">return</span><span class="c3">&nbsp;errs </span><span class="c0">?</span><span class="c3">&nbsp;</span><span class="c17">Observable</span><span class="c0">.</span><span class="c3">of</span><span class="c0">(</span><span class="c3">errs</span><span class="c0">)</span><span class="c3 c6">&nbsp;</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c17">Observable</span><span class="c0">.</span><span class="c3">merge</span><span class="c0">(</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c14">this</span><span class="c0">.</span><span class="c3 c6">userValidator</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c14">this</span><span class="c0">.</span><span class="c3 c6">otherValidator</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">).</span><span class="c3">map</span><span class="c0">(</span><span class="c3">myErrorMerger</span><span class="c0">);</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">});</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c0">};</span></p><p class="c2"><span class="c0">}</span></p></td></tr></tbody></table><p class="c9"><span class="c5 c4">All of the above you can already achieve with the normal validation flow. Let&#39;s review some customizations that are only possible with validator chains.</span></p><p class="c9"><span class="c20 c4">Customization 1: Gate validation on arbitrary function</span></p><p class="c9"><span class="c5 c4">You can choose to delay validation until a specific condition in your application has been met. The condition could be anything - whether or not 8 other controls have been touched, whether the form has submitted, the character count, etc.</span></p><a id="t.6c9395f46ff56676f88c72ad48cfe4e637290a18"></a><a id="t.24"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c3">myChain</span><span class="c0">(</span><span class="c3">ctrl</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c17">AbstractControl</span><span class="c0">):</span><span class="c3">&nbsp;</span><span class="c17">ValidatorChain</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c14">return</span><span class="c3">&nbsp;</span><span class="c0">(</span><span class="c3">obs</span><span class="c0">)</span><span class="c3">&nbsp;</span><span class="c0">=&gt;</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; </span><span class="c14">return</span><span class="c3 c6">&nbsp;obs</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">.</span><span class="c3">skipWhile</span><span class="c0">((</span><span class="c3">ctrl</span><span class="c0">)</span><span class="c3">&nbsp;</span><span class="c0">=&gt;</span><span class="c3">&nbsp;</span><span class="c47">//some arbitary condition )</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">.</span><span class="c3">map</span><span class="c0">(</span><span class="c17">Validators</span><span class="c0">.</span><span class="c3">required</span><span class="c0">)</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">.</span><span class="c3">switchMap</span><span class="c0">(</span><span class="c3">errs </span><span class="c0">=&gt;</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c14">return</span><span class="c3">&nbsp;errs </span><span class="c0">?</span><span class="c3">&nbsp;</span><span class="c17">Observable</span><span class="c0">.</span><span class="c3">of</span><span class="c0">(</span><span class="c3">errs</span><span class="c0">)</span><span class="c3 c6">&nbsp;</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c14">this</span><span class="c0">.</span><span class="c3">userValidator</span><span class="c0">.</span><span class="c3">startWith</span><span class="c0">(</span><span class="c3">PENDING</span><span class="c0">);</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">});</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c0">};</span></p><p class="c2"><span class="c0">}</span></p></td></tr></tbody></table><p class="c9"><span class="c5 c4">If you prefer, you can also choose to mix in our default validation chain to avoid having to rewrite standard functionality. You just have to pass in validator functions the normal way:</span></p><a id="t.c55e85606eec3192de9e13a1ad94ca0d87009619"></a><a id="t.25"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c3">ctrl </span><span class="c0">=</span><span class="c3">&nbsp;</span><span class="c14">new</span><span class="c3">&nbsp;</span><span class="c17">FormControl</span><span class="c0">(</span><span class="c43">&#39;&#39;</span><span class="c0">,</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;chain</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c14">this</span><span class="c0">.</span><span class="c3">myChain</span><span class="c0">,</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;validators</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c17">Validators</span><span class="c0">.</span><span class="c3">required</span><span class="c0">,</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;asyncValidators</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c14">this</span><span class="c0">.</span><span class="c3 c6">userValidator </span></p><p class="c2"><span class="c0">});</span></p><p class="c2 c28"><span class="c3 c6"></span></p><p class="c2"><span class="c3">myChain</span><span class="c0">(</span><span class="c3">ctrl</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c17">AbstractControl</span><span class="c0">):</span><span class="c3">&nbsp;</span><span class="c17">ValidatorChain</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c14">return</span><span class="c3">&nbsp;</span><span class="c0">(</span><span class="c3">obs</span><span class="c0">)</span><span class="c3">&nbsp;</span><span class="c0">=&gt;</span><span class="c3">&nbsp;obs</span><span class="c0">.</span><span class="c3">skipWhile</span><span class="c0">((</span><span class="c3">ctrl</span><span class="c0">)</span><span class="c3">&nbsp;</span><span class="c0">=&gt;</span><span class="c3">&nbsp;</span><span class="c47">//some arbitary condition )</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">.</span><span class="c3">let</span><span class="c0">(</span><span class="c3">defaultChain</span><span class="c0">(</span><span class="c3">ctrl</span><span class="c0">));</span></p><p class="c2"><span class="c0 c6">}</span></p></td></tr></tbody></table><p class="c9"><span class="c4 c32">Customization 2: &nbsp;Skip PENDING update</span></p><p class="c9"><span class="c5 c4">Another easy customization would be to jump straight from the old validation status to the new one, without a PENDING status in between. </span></p><p class="c9"><span class="c5 c4">This is handy if you have validation styles that will change based on validity. Let&#39;s say your text field background should be red if INVALID and green if VALID. If you have async validators, as soon as validation starts running, your status will change from INVALID to PENDING to VALID, instead of INVALID to VALID. Effectively you&#39;ll have a 500ms flash of white background. </span></p><p class="c9"><span class="c4">You can skip the PENDING state by omitting the </span><span class="c29">startWith</span><span class="c4">&nbsp;operator. </span></p><a id="t.cfaf9b0d108aad8f6442fc1115eb732e4c2cd082"></a><a id="t.26"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c3">skipPendingChain</span><span class="c0">(</span><span class="c3">ctrl</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c17">AbstractControl</span><span class="c0">):</span><span class="c3">&nbsp;</span><span class="c17">ValidatorChain</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c14">return</span><span class="c3">&nbsp;</span><span class="c0">(</span><span class="c3">obs</span><span class="c0">)</span><span class="c3">&nbsp;</span><span class="c0">=&gt;</span><span class="c3">&nbsp;obs</span><span class="c0">.</span><span class="c3">map</span><span class="c0">(</span><span class="c3">ctrl</span><span class="c0">.</span><span class="c3">validator</span><span class="c0">)</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">.</span><span class="c3">switchMap</span><span class="c0">(</span><span class="c3">errs </span><span class="c0">=&gt;</span><span class="c3">&nbsp;errs </span><span class="c0">?</span><span class="c3">&nbsp;</span><span class="c17">Observable</span><span class="c0">.</span><span class="c3">of</span><span class="c0">(</span><span class="c3">errs</span><span class="c0">)</span><span class="c3 c6">&nbsp;</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">:</span><span class="c3">&nbsp;ctrl</span><span class="c0">.</span><span class="c3">asyncValidator</span><span class="c0">(</span><span class="c3">ctrl</span><span class="c0">));</span></p><p class="c2"><span class="c0 c6">}</span></p></td></tr></tbody></table><p class="c9"><span class="c5 c4">If we find that this is a common case, we might consider exporting this chain as a built-in for people to use.</span></p><p class="c9"><span class="c20 c4">Customization 3: Always run async validators</span></p><p class="c9"><span class="c5 c4">In the default pipeline, async validators are not run until sync validator pass. &nbsp;In practice, this means that you&#39;ll never have sync and async errors at the same time. If your UI requires displaying all errors for a field, this is difficult to accomplish with the default pipeline. </span></p><p class="c9"><span class="c5 c4">Creating your own chain, you can choose to run async validators regardless of the result of the sync validators.</span></p><a id="t.dc13a2ea0167a57d834150bfa9372a621777b63f"></a><a id="t.27"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c3">runAllChain</span><span class="c0">(</span><span class="c3">ctrl</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c17">AbstractControl</span><span class="c0">):</span><span class="c3">&nbsp;</span><span class="c17">ValidatorChain</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c14">return</span><span class="c3">&nbsp;</span><span class="c0">(</span><span class="c3">obs</span><span class="c0">)</span><span class="c3">&nbsp;</span><span class="c0">=&gt;</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; </span><span class="c14">return</span><span class="c3">&nbsp;obs</span><span class="c0">.</span><span class="c3">map</span><span class="c0">(</span><span class="c3">ctrl</span><span class="c0">.</span><span class="c3">validator</span><span class="c0">)</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">.</span><span class="c3">switchMap</span><span class="c0">(</span><span class="c3">syncErrs </span><span class="c0">=&gt;</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c14">return</span><span class="c3">&nbsp;ctrl</span><span class="c0">.</span><span class="c3">asyncValidator</span><span class="c0">(</span><span class="c3">ctrl</span><span class="c0">)</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">.</span><span class="c3">scan</span><span class="c0">((</span><span class="c3">errs</span><span class="c0">,</span><span class="c3">&nbsp;curr</span><span class="c0">)</span><span class="c3">&nbsp;</span><span class="c0">=&gt;</span><span class="c3">&nbsp;</span><span class="c0">{...</span><span class="c3">errs</span><span class="c0">,</span><span class="c3">&nbsp;</span><span class="c0">...</span><span class="c3">curr</span><span class="c0">},</span><span class="c3">&nbsp;syncErrs</span><span class="c0">)</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">.</span><span class="c3">map</span><span class="c0">(</span><span class="c3">errMap </span><span class="c0">=&gt;</span><span class="c3">&nbsp;</span><span class="c17">Object</span><span class="c0">.</span><span class="c3">keys</span><span class="c0">(</span><span class="c3">errMap</span><span class="c0">).</span><span class="c3">length </span><span class="c0">?</span><span class="c3">&nbsp;errMap </span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c14">null</span><span class="c0">);</span></p><p class="c2"><span class="c3 c6">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">});</span><span class="c3 c6">&nbsp; &nbsp; </span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c0">}</span></p><p class="c2"><span class="c0">}</span></p></td></tr></tbody></table><p class="c9"><span class="c5 c4">To make error merging easier, we could also consider exporting some middleware to handle this:</span></p><a id="t.cbb36873bbffe5c89c9f22665d62594d47091d04"></a><a id="t.28"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c3">myChain</span><span class="c0">(</span><span class="c3">ctrl</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c17">AbstractControl</span><span class="c0">):</span><span class="c3">&nbsp;</span><span class="c17">ValidatorChain</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c14">return</span><span class="c3">&nbsp;</span><span class="c0">(</span><span class="c3">obs</span><span class="c0">)</span><span class="c3">&nbsp;</span><span class="c0">=&gt;</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; </span><span class="c14">return</span><span class="c3">&nbsp;obs</span><span class="c0">.</span><span class="c3">map</span><span class="c0">(</span><span class="c3">ctrl</span><span class="c0">.</span><span class="c3">validator</span><span class="c0">)</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">.</span><span class="c3">switchMap</span><span class="c0">(</span><span class="c3">syncErrs </span><span class="c0">=&gt;</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c14">return</span><span class="c3">&nbsp;ctrl</span><span class="c0">.</span><span class="c3">asyncValidator</span><span class="c0">(</span><span class="c3">ctrl</span><span class="c0">)</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">.</span><span class="c3">startWith</span><span class="c0">(</span><span class="c3">syncErrs</span><span class="c0">)</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">.</span><span class="c3">let</span><span class="c0">(</span><span class="c3">mergeAllErrors</span><span class="c0">)</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">});</span><span class="c3 c6">&nbsp; &nbsp; </span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c0">}</span></p><p class="c2"><span class="c0">}</span></p></td></tr></tbody></table><p class="c9"><span class="c20 c4">Customization 4: Debounce validation separately</span></p><p class="c9"><span class="c5 c4">There is already a way to debounce both value and validity together with the debounce option. But let&#39;s say you have a UI that displays the value of the form elsewhere as you type it, and you have expensive validation that you only want to run every so often. If you use the debounce option that gates the value as well, the display will seem to have latency. Or perhaps you just want all your validation logic in one place.</span></p><p class="c9"><span class="c5 c4">In these cases, you can allow the values to update immediately but wait to run validation by debouncing in the custom chain instead. </span></p><a id="t.76a289fb1c4108eb78e4b025a7f6019c1c09fc40"></a><a id="t.29"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c3">myChain</span><span class="c0">(</span><span class="c3">ctrl</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c17">AbstractControl</span><span class="c0">):</span><span class="c3">&nbsp;</span><span class="c17">ValidatorChain</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c14">return</span><span class="c3">&nbsp;</span><span class="c0">(</span><span class="c3">obs</span><span class="c0">)</span><span class="c3">&nbsp;</span><span class="c0">=&gt;</span><span class="c3">&nbsp;obs</span><span class="c0">.</span><span class="c3">debounceTime</span><span class="c0">(</span><span class="c11">500</span><span class="c0">)</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">.</span><span class="c3">let</span><span class="c0">(</span><span class="c3">defaultChain</span><span class="c0">(</span><span class="c3">ctrl</span><span class="c0">));</span></p><p class="c2"><span class="c0">}</span></p></td></tr></tbody></table><p class="c9"><span class="c4">There are tradeoffs to this pattern. This validation chain is used in both model -&gt; view and view-&gt; model directions. Unlike when you set the debounce option (which is applied higher upstream to affect only view -&gt; model), validation will also wait 500ms to run when setting the value programmatically.</span></p><h3 class="c9 c36" id="h.m5fkictb5ysp"><span class="c51">Implementation details</span></h3><p class="c9"><span class="c20 c4">Managing subscriptions</span></p><p class="c9"><span class="c5 c4">Once the internal forms pipeline has been converted into observable chains, something will have to subscribe to the chain to kick off the process of updating value and validation statuses.</span></p><p class="c9"><span class="c5 c4">In template-driven forms, the source of truth for the form is the view. So if the form directives are destroyed, the form controls are also de-registered from their parents and destroyed. Given this coupling, the template-driven form directives can be responsible for subscribing to their form controls on init and unsubscribing when they are destroyed. There is no reason to run validation on a form control that doesn&#39;t exist. Developers using the template-driven forms module shouldn&#39;t have to do anything differently.</span></p><p class="c9"><span class="c5 c4">On the other hand, in reactive forms, the source of truth for the form is the form model in the component class. So there may well be cases where the view does not currently display the form control (perhaps it&#39;s part of a collapsed section of the form), but validation should still run. In this case, the framework cannot manage the subscription because we don&#39;t know when it&#39;s appropriate to unsubscribe. As such, the application developer should be responsible for subscribing to value and validation updates when they are interested and unsubscribing when they&#39;re no longer relevant. </span></p><p class="c9"><span class="c5 c4">We can simplify this by making the form control instance itself implement the Observable interface. &nbsp;This means that in simple cases where the view and the form model match -- and subscription should be managed based on form control presence in the DOM -- you can just use the async pipe to manage subscriptions.</span></p><a id="t.03d790d32ab6aa9612f051c3c744a4458941c2f4"></a><a id="t.30"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c21">&lt;input</span><span class="c49">&nbsp;[formControl]</span><span class="c0">=</span><span class="c49">&quot;myCtrl | async&quot;</span><span class="c21">&gt;</span></p></td></tr></tbody></table><p class="c9"><span class="c5 c4">If the view and the form model are not always in sync (again, if some controls are not currently present in the DOM but validation should run), the developer can unsubscribe manually when the top level component is destroyed (or whenever works best for their app).</span></p><p class="c9"><span class="c4">It&#39;s worth noting that form groups will automatically kick off the value/validation chain for their children, so only one async pipe (or subscription) would be needed at the top level.</span></p><p class="c9"><span class="c20 c4">Value change stream</span></p><p class="c9"><span class="c5 c4">In order to properly support rate limiting, we will need to redesign the internals of how value and validity are updated. Currently we are using a callback-based system that makes debouncing and cancelling previous subscriptions difficult. &nbsp;</span></p><p class="c9"><span class="c4">Ideally, we&#39;d want a stream that starts at the value change event in the DOM (usually </span><span class="c29">input</span><span class="c5 c4">, but depends on the control type) and propagates through the validators to set the appropriate errors and statuses. </span></p><p class="c9"><span class="c5 c4">At present, we capture the value change events through host listeners in control value accessors. </span></p><p class="c9"><span class="c6 c4 c27">Example accessor</span></p><a id="t.c12429c0725fe38cb018df0ae0485d0d30d6e146"></a><a id="t.31"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c3">host</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c43">&#39;(input)&#39;</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c43">&#39;_onChange($event.target.value)&#39;</span></p><p class="c2"><span class="c0">}</span></p></td></tr></tbody></table><p class="c9"><span class="c4">When the event is triggered, we call the </span><span class="c29">onChange</span><span class="c5 c4">&nbsp;function that was registered when the control was set up.</span></p><p class="c9"><span class="c4">One option is to create a stream with something like </span><span class="c29">Observable.fromEvent(this.el.nativeElement, &#39;input&#39;)</span><span class="c4">, then subscribe to that stream when we link the control object to the directive. &nbsp;However, this would require </span><span class="c23">all</span><span class="c5 c4">&nbsp;control value accessors to surface a value change stream that as yet doesn&#39;t exist. </span></p><p class="c9"><span class="c5 c4">Adding that functionality is acceptable overhead for built-in value accessors, but it will also require that all custom value accessors created by external developers be updated. This is a formidable breaking change for existing applications, and one that also requires some working knowledge of rxjs. Updating may be especially painful for companies without experience with it.</span></p><p class="c9"><span class="c4">Instead, we might want to keep the logic in the value accessors the same to avoid breaking changes, and create our own stream farther down the line that emits whenever </span><span class="c29">onChange</span><span class="c4">&nbsp;is called. Then we could use </span><span class="c29">let</span><span class="c5 c4">&nbsp;to conditionally debounce that stream depending on whether the control has the debounce option set.</span></p><p class="c9"><span class="c4">We will need two separate processes: one for model -&gt; view changes and one for view-&gt;model changes. This is necessary because we only want our </span><span class="c29">debounce</span><span class="c4">&nbsp;or </span><span class="c29">updateOnTouched</span><span class="c5 c4">&nbsp;logic to run in the view -&gt; model direction. It doesn&#39;t make sense to delay programmatic updates of values (like a form reset or setting a default value). &nbsp;</span></p><p class="c9"><span class="c4">In </span><span class="c29">AbstractControl</span><span class="c5 c4">&nbsp;(general idea):</span></p><a id="t.3fbba34cecde31dcf6c40c002fea52ce61813191"></a><a id="t.32"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c3">_initObservables</span><span class="c0">()</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c14">this</span><span class="c0">.</span><span class="c3">_viewValues </span><span class="c0">=</span><span class="c3">&nbsp;</span><span class="c14">new</span><span class="c3">&nbsp;</span><span class="c17">Subject</span><span class="c0">();</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c14">this</span><span class="c0">.</span><span class="c3">_modelValues </span><span class="c0">=</span><span class="c3">&nbsp;</span><span class="c14">new</span><span class="c3">&nbsp;</span><span class="c17">Subject</span><span class="c0">();</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c14">this</span><span class="c0">.</span><span class="c3">_initValidatorChain</span><span class="c0">();</span></p><p class="c2"><span class="c0">}</span></p><p class="c2 c28"><span class="c3 c6"></span></p><p class="c2"><span class="c3">_initValidatorChain</span><span class="c0">()</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c17">Observable</span><span class="c0">.</span><span class="c3">merge</span><span class="c0">(</span><span class="c14">this</span><span class="c0">.</span><span class="c3">viewValues</span><span class="c0">,</span><span class="c3">&nbsp;</span><span class="c14">this</span><span class="c0">.</span><span class="c3">modelValues</span><span class="c0">)</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp;</span><span class="c0">.</span><span class="c3">mapTo</span><span class="c0">(</span><span class="c14">this</span><span class="c0">)</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp;</span><span class="c0">.</span><span class="c3">let</span><span class="c0">(</span><span class="c3">obs </span><span class="c0">=&gt;</span><span class="c3">&nbsp;</span><span class="c14">this</span><span class="c0">.</span><span class="c3">chain </span><span class="c0">?</span><span class="c3">&nbsp;</span><span class="c14">this</span><span class="c0">.</span><span class="c3">chain</span><span class="c0">(</span><span class="c14">this</span><span class="c0">)(</span><span class="c3">obs</span><span class="c0">)</span><span class="c3">&nbsp;</span><span class="c0">:</span><span class="c3">&nbsp;defaultChain</span><span class="c0">(</span><span class="c14">this</span><span class="c0">)(</span><span class="c3">obs</span><span class="c0">)</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp;</span><span class="c0">.</span><span class="c3">map</span><span class="c0">(</span><span class="c14">this</span><span class="c0">.</span><span class="c3">setErrors</span><span class="c0">);</span></p><p class="c2"><span class="c0">}</span></p><p class="c2 c28"><span class="c3 c6"></span></p><p class="c2"><span class="c14">get</span><span class="c3">&nbsp;viewValues</span><span class="c0">()</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c14">return</span><span class="c3">&nbsp;</span><span class="c14">this</span><span class="c0">.</span><span class="c3 c6">_viewValues</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; </span><span class="c0">.</span><span class="c3">let</span><span class="c0">(</span><span class="c3">obs </span><span class="c0">=&gt;</span><span class="c3">&nbsp;</span><span class="c14">this</span><span class="c0">.</span><span class="c3">debounce </span><span class="c0">?</span><span class="c3">&nbsp;obs</span><span class="c0">.</span><span class="c3">debounceTime</span><span class="c0">(</span><span class="c14">this</span><span class="c0">.</span><span class="c3">debounce</span><span class="c0">)</span><span class="c3">&nbsp;</span><span class="c0">:</span><span class="c3">&nbsp;obs</span><span class="c0">);</span></p><p class="c2"><span class="c0">}</span></p><p class="c2 c28"><span class="c3 c6"></span></p><p class="c2"><span class="c14">get</span><span class="c3">&nbsp;modelValues</span><span class="c0">()</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c14">return</span><span class="c3">&nbsp;</span><span class="c14">this</span><span class="c0">.</span><span class="c3">_modelValues</span><span class="c0">;</span></p><p class="c2"><span class="c0">}</span></p><p class="c2 c28"><span class="c3 c6"></span></p><p class="c2"><span class="c3">setValue</span><span class="c0">(</span><span class="c3">value</span><span class="c0">:</span><span class="c3">&nbsp;any</span><span class="c0">)</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c0">...</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c14">this</span><span class="c0">.</span><span class="c3">_modelValues</span><span class="c0">.</span><span class="c14">next</span><span class="c0">(</span><span class="c3">value</span><span class="c0">);</span></p><p class="c2"><span class="c0 c6">}</span></p></td></tr></tbody></table><p class="c9"><span class="c4">In </span><span class="c29">shared.ts:</span></p><a id="t.5953a629b41745dc40c6f7475530d0962b81b1f2"></a><a id="t.33"></a><table class="c41"><tbody><tr class="c22"><td class="c61" colspan="1" rowspan="1"><p class="c2"><span class="c3">dir</span><span class="c0">.</span><span class="c3">valueAccessor</span><span class="c0">.</span><span class="c3">registerOnChange</span><span class="c0">(</span><span class="c3">val </span><span class="c0">=&gt;</span><span class="c3">&nbsp;control</span><span class="c0">.</span><span class="c3">_viewValues</span><span class="c0">.</span><span class="c14">next</span><span class="c0">(</span><span class="c3">val</span><span class="c0">));</span></p><p class="c2"><span class="c0">&hellip;</span></p><p class="c2 c28"><span class="c3 c6"></span></p><p class="c2 c28"><span class="c3 c6"></span></p><p class="c2"><span class="c3">cleanUpControl</span><span class="c0">()</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c0">&hellip;</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;control</span><span class="c0">.</span><span class="c3">_viewValues</span><span class="c0">.</span><span class="c3">dispose</span><span class="c0">();</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;control</span><span class="c0">.</span><span class="c3">_modelValues</span><span class="c0">.</span><span class="c3">dispose</span><span class="c0">();</span></p><p class="c2"><span class="c0 c6">}</span></p></td></tr></tbody></table><p class="c9 c28"><span class="c5 c4"></span></p><p class="c9"><span class="c4 c32">Composing async validators</span></p><p class="c9"><span class="c4">Currently, we compose async validators with the help of </span><span class="c29">forkJoin</span><span class="c4">. Specifically, we call each validator, convert it to an observable if it isn&rsquo;t one already (using </span><span class="c29">toObservable</span><span class="c4">, which is a wrapper for </span><span class="c29">fromPromise</span><span class="c5 c4">), then merge the errors together when all the observables complete. </span></p><p class="c9"><span class="c6 c4 c27">Original (simplified for readability):</span></p><a id="t.3306d4811b057d44fd1d823befecce89c9feb87b"></a><a id="t.34"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c14">static</span><span class="c3">&nbsp;composeAsync</span><span class="c0">(</span><span class="c3">validators</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c17">AsyncValidatorFn</span><span class="c0">[]):</span><span class="c3">&nbsp;</span><span class="c17">AsyncValidatorFn</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c0">...</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c14">return</span><span class="c3">&nbsp;</span><span class="c14">function</span><span class="c0">(</span><span class="c3">control</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c17">AbstractControl</span><span class="c0">)</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp;</span><span class="c14">const</span><span class="c3">&nbsp;observables </span><span class="c0">=</span><span class="c3">&nbsp;validators</span><span class="c0">.</span><span class="c3">map</span><span class="c0">(</span><span class="c3">v </span><span class="c0">=&gt;</span><span class="c3">&nbsp;v</span><span class="c0">(</span><span class="c3">control</span><span class="c0">))</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">.</span><span class="c3">map</span><span class="c0">(</span><span class="c3">toObservable</span><span class="c0">);</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp;</span><span class="c14">return</span><span class="c3">&nbsp;</span><span class="c17">Observable</span><span class="c0">.</span><span class="c3">forkJoin</span><span class="c0">(</span><span class="c3">observables</span><span class="c0">).</span><span class="c3">map</span><span class="c0">(</span><span class="c3">_mergeErrors</span><span class="c0">);</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c0">};</span></p><p class="c2"><span class="c0">}</span></p></td></tr></tbody></table><p class="c9"><span class="c5 c4">This approach requires all validators to complete before emitting a value. </span></p><p class="c9"><span class="c5 c4">forkJoin diagram (current state):</span></p><a id="t.9a7c080b22beb92d32e39455836efaa24099c4f8"></a><a id="t.35"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c3">obs </span><span class="c11">1</span><span class="c0">:</span><span class="c3">&nbsp; &nbsp; </span><span class="c0">-</span><span class="c3">&nbsp;</span><span class="c0">{</span><span class="c11">1</span><span class="c0">}</span><span class="c3">&nbsp;</span><span class="c0">-|</span></p><p class="c2"><span class="c3">obs </span><span class="c11">2</span><span class="c0">:</span><span class="c3">&nbsp; &nbsp; </span><span class="c0">-</span><span class="c3">&nbsp; </span><span class="c0">-</span><span class="c3">&nbsp; </span><span class="c0">-</span><span class="c3">&nbsp;</span><span class="c0">-</span><span class="c3">&nbsp;</span><span class="c14">null</span><span class="c0">--|</span></p><p class="c2"><span class="c3">forkJoin</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c0">-</span><span class="c3">&nbsp; </span><span class="c0">-</span><span class="c3">&nbsp; </span><span class="c0">-</span><span class="c3">&nbsp;</span><span class="c0">-</span><span class="c3">&nbsp;</span><span class="c0">-</span><span class="c3">&nbsp; &nbsp;</span><span class="c0">-</span><span class="c3">&nbsp;</span><span class="c0">[{</span><span class="c11">1</span><span class="c0">},</span><span class="c3">&nbsp;</span><span class="c14">null</span><span class="c0">]</span><span class="c3 c6">&nbsp;</span></p><p class="c2"><span class="c3">errors</span><span class="c0">:</span><span class="c3">&nbsp; &nbsp;N &nbsp;</span><span class="c0">-</span><span class="c3">&nbsp; </span><span class="c0">-</span><span class="c3">&nbsp;</span><span class="c0">-</span><span class="c3">&nbsp;</span><span class="c0">-</span><span class="c3">&nbsp; &nbsp;</span><span class="c0">-</span><span class="c3">&nbsp;</span><span class="c0">{</span><span class="c11">1</span><span class="c0">}</span><span class="c3 c6">&nbsp; </span></p><p class="c2"><span class="c3">status</span><span class="c0">:</span><span class="c3">&nbsp; &nbsp;P &nbsp;</span><span class="c0">-</span><span class="c3">&nbsp; </span><span class="c0">-</span><span class="c3">&nbsp;</span><span class="c0">-</span><span class="c3">&nbsp;</span><span class="c0">-</span><span class="c3">&nbsp; &nbsp;</span><span class="c0">-</span><span class="c3 c6">&nbsp;I &nbsp; </span></p><p class="c2 c28"><span class="c3 c6"></span></p><p class="c2"><span class="c17">Key</span><span class="c0">:</span><span class="c3 c6">&nbsp;</span></p><p class="c2"><span class="c3">N </span><span class="c0">-</span><span class="c3">&nbsp;</span><span class="c14">null</span></p><p class="c2"><span class="c0">{</span><span class="c11">1</span><span class="c0">}</span><span class="c3">&nbsp;</span><span class="c0">-</span><span class="c3">&nbsp;shorthand </span><span class="c14">for</span><span class="c3 c6">&nbsp;error map</span></p><p class="c2"><span class="c0">|</span><span class="c3">&nbsp;</span><span class="c0">-</span><span class="c3 c6">&nbsp;completion</span></p><p class="c2"><span class="c3">P </span><span class="c0">-</span><span class="c3 c6">&nbsp;PENDING</span></p><p class="c2"><span class="c3">I </span><span class="c0">-</span><span class="c3 c6">&nbsp;INVALID</span></p><p class="c2"><span class="c3">V </span><span class="c0">-</span><span class="c3">&nbsp;VALID</span></p></td></tr></tbody></table><p class="c9"><span class="c5 c4">If we instead update errors whenever the observable emits, we could:</span></p><ul class="c33 lst-kix_qwmtq0kjlnrc-0 start"><li class="c9 c19"><span class="c5 c4">Avoid developer confusion about when errors are set</span></li><li class="c9 c19"><span class="c5 c4">Open up some possibilities for &ldquo;push&rdquo; based validation</span></li></ul><p class="c9"><span class="c4">One option is to use </span><span class="c4 c50">combineLatest</span><span class="c5 c4">.</span></p><a id="t.64a53fdd99db8e20af112364f2a00e773de83a0f"></a><a id="t.36"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c14">static</span><span class="c3">&nbsp;composeAsync</span><span class="c0">(</span><span class="c3">validators</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c17">AsyncValidatorFn</span><span class="c0">[]):</span><span class="c3">&nbsp;</span><span class="c17">AsyncValidatorFn</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c0">...</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c14">return</span><span class="c3">&nbsp;</span><span class="c14">function</span><span class="c0">(</span><span class="c3">control</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c17">AbstractControl</span><span class="c0">)</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp;</span><span class="c14">const</span><span class="c3">&nbsp;observables </span><span class="c0">=</span><span class="c3">&nbsp;validators</span><span class="c0">.</span><span class="c3">map</span><span class="c0">(</span><span class="c3">v </span><span class="c0">=&gt;</span><span class="c3">&nbsp;v</span><span class="c0">(</span><span class="c3">control</span><span class="c0">))</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">.</span><span class="c3">map</span><span class="c0">(</span><span class="c3">toObservable</span><span class="c0">);</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp;</span><span class="c14">return</span><span class="c3">&nbsp;</span><span class="c17">Observable</span><span class="c0">.</span><span class="c3">combineLatest</span><span class="c0">(</span><span class="c3">observables</span><span class="c0">).</span><span class="c3">map</span><span class="c0">(</span><span class="c3">_mergeErrors</span><span class="c0">);</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c0">};</span></p><p class="c2"><span class="c0">}</span></p></td></tr></tbody></table><p class="c9"><span class="c5 c4">combineLatest diagram:</span></p><a id="t.0752896a9893b3ba9aa26f292627f8d4d597e5d8"></a><a id="t.37"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c3">obs </span><span class="c11">1</span><span class="c0">:</span><span class="c3">&nbsp; &nbsp; </span><span class="c0">-</span><span class="c3">&nbsp; &nbsp;</span><span class="c0">{</span><span class="c11">1</span><span class="c0">}</span><span class="c3">&nbsp; </span><span class="c0">-</span><span class="c3">&nbsp;</span><span class="c0">-</span><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">-</span><span class="c3">&nbsp;</span><span class="c14">null</span><span class="c3 c6">&nbsp; &nbsp;</span></p><p class="c2"><span class="c3">obs </span><span class="c11">2</span><span class="c0">:</span><span class="c3">&nbsp; &nbsp; </span><span class="c0">-</span><span class="c3">&nbsp; &nbsp;</span><span class="c0">-</span><span class="c3">&nbsp; &nbsp; </span><span class="c0">-</span><span class="c3">&nbsp;</span><span class="c14">null</span><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">-</span><span class="c3">&nbsp;</span><span class="c0">-</span></p><p class="c2"><span class="c3">combine</span><span class="c0">:</span><span class="c3">&nbsp; </span><span class="c0">-</span><span class="c3">&nbsp; &nbsp;</span><span class="c0">-</span><span class="c3">&nbsp; &nbsp; </span><span class="c0">-</span><span class="c3">&nbsp;</span><span class="c0">[{</span><span class="c11">1</span><span class="c0">},</span><span class="c3">&nbsp;</span><span class="c14">null</span><span class="c0">]</span><span class="c3">&nbsp;</span><span class="c0">-</span><span class="c3">&nbsp;</span><span class="c0">[</span><span class="c14">null</span><span class="c0">,</span><span class="c3">&nbsp;</span><span class="c14">null</span><span class="c0">]</span></p><p class="c2"><span class="c3">errors</span><span class="c0">:</span><span class="c3">&nbsp; &nbsp;N &nbsp; </span><span class="c0">-</span><span class="c3">&nbsp; &nbsp; </span><span class="c0">-</span><span class="c3">&nbsp;</span><span class="c0">{</span><span class="c11">1</span><span class="c0">}</span><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">-</span><span class="c3">&nbsp;</span><span class="c14">null</span></p><p class="c2"><span class="c3">status</span><span class="c0">:</span><span class="c3">&nbsp; &nbsp;P &nbsp; </span><span class="c0">-</span><span class="c3">&nbsp; &nbsp; </span><span class="c0">-</span><span class="c3">&nbsp;I &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">-</span><span class="c3">&nbsp;V</span></p></td></tr></tbody></table><p class="c9"><span class="c5 c4">This operator doesn&#39;t require the streams to complete, but it does require that both streams have a latest value before emitting. This means that both validators must contribute a value initially before it will emit errors, but after that, errors and statuses are updated immediately when either emits. This approach keeps the behavior of PENDING consistent with its current definition, so we don&rsquo;t set a status prematurely while some validators are still running.</span></p><p class="c9"><span class="c4">Another possibility is to </span><span class="c38">Observable.merge</span><span class="c5 c4">&nbsp;the observables, then merge the errors as they come in.</span></p><p class="c9"><span class="c5 c4">merge diagram:</span></p><a id="t.7b8394ef5e1dc3a341a99d409a8397b255c7ffc3"></a><a id="t.38"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c3">obs </span><span class="c11">1</span><span class="c0">:</span><span class="c3">&nbsp; &nbsp; </span><span class="c0">-</span><span class="c3">&nbsp; </span><span class="c14">null</span><span class="c3">&nbsp;</span><span class="c0">-|</span></p><p class="c2"><span class="c3">obs </span><span class="c11">2</span><span class="c0">:</span><span class="c3">&nbsp; &nbsp; </span><span class="c0">-</span><span class="c3">&nbsp; </span><span class="c0">-</span><span class="c3">&nbsp; &nbsp; </span><span class="c0">-</span><span class="c3">&nbsp;</span><span class="c0">{</span><span class="c11">1</span><span class="c0">}</span><span class="c3">&nbsp;</span><span class="c0">-|</span></p><p class="c2"><span class="c3">merge</span><span class="c0">:</span><span class="c3">&nbsp; &nbsp; </span><span class="c0">-</span><span class="c3">&nbsp; </span><span class="c14">null</span><span class="c3">&nbsp;</span><span class="c0">-</span><span class="c3">&nbsp;</span><span class="c0">{</span><span class="c11">1</span><span class="c0">}</span><span class="c3">&nbsp;</span><span class="c0">-</span></p><p class="c2"><span class="c3">errors</span><span class="c0">:</span><span class="c3">&nbsp; &nbsp;N &nbsp;</span><span class="c14">null</span><span class="c3">&nbsp;</span><span class="c0">-</span><span class="c3">&nbsp;</span><span class="c0">{</span><span class="c11">1</span><span class="c0">}</span><span class="c3">&nbsp;</span><span class="c0">-</span></p><p class="c2"><span class="c3">status</span><span class="c0">:</span><span class="c3">&nbsp; &nbsp;P &nbsp;V &nbsp; &nbsp;</span><span class="c0">-</span><span class="c3">&nbsp;I &nbsp; </span><span class="c0">-</span><span class="c3">&nbsp; &nbsp; </span></p></td></tr></tbody></table><p class="c9"><span class="c5 c4">The problem with this is that it&#39;s not clear when validation has completed. If the first async validator has no errors, it returns a false positive for VALID early on, which could be misleading. It will only become INVALID once the second validator emits. &nbsp;</span></p><p class="c9"><span class="c5 c4">If we want to pass through feedback from the first async validator when it comes in, we will need to change how validation statuses are calculated. With the current definition, the presence of errors always maps to an INVALID status and the presence of null always maps to a VALID status. There&rsquo;s no way to set errors as they come in while simultaneously indicating that validators are still pending.</span></p><p class="c9"><span class="c4">This problem will require more design, so the planning will be discussed in a separate design doc. For the purposes of adding validator chains, </span><span class="c4 c60">combineLatest</span><span class="c5 c4">&nbsp;will be truest to our current behavior without requiring the observables to complete or significant breaking changes in status calculation.</span></p><p class="c9"><span class="c5 c4">It&#39;s worth noting that this is just the default async composition behavior. Developers can already compose their own sync or async validators in any way they like before passing them in.</span></p><h1 class="c30" id="h.ydr456a07ivp"><span class="c6 c4 c39">Caveats</span></h1><p class="c9"><span class="c4 c32">Status change events</span></p><p class="c9"><span class="c5 c4">In our current codebase, validation errors from sync validators are set immediately as soon as the value is updated on that control. Then when any async validators on the control complete, they set the errors on the control and update the tree from the bottom up. This makes sense because a group&rsquo;s status depends on the statuses of the group&rsquo;s children. This tree-wide error setting doesn&rsquo;t happen when values are updated by sync validators because each node in the tree will already be visited to update its value.</span></p><p class="c9"><span class="c5 c4">Now that we are setting errors whenever validators emit a value, we need two processes: one for errors set as soon as the value is updated and one for errors that come in later. Otherwise, if we always update errors up the tree when a control&rsquo;s error is set, we&rsquo;ll get the following behavior:</span></p><ul class="c33 lst-kix_rvd88bm3876g-0 start"><li class="c9 c19"><span class="c5 c4">Control value updated</span></li><li class="c9 c19"><span class="c5 c4">Control validators run</span></li><li class="c9 c19"><span class="c5 c4">Control errors set</span></li><li class="c9 c19"><span class="c5 c23">Group errors set</span></li><li class="c9 c19 c28"><span class="c5 c4"></span></li><li class="c9 c19"><span class="c5 c4">Group value updated</span></li><li class="c9 c19"><span class="c5 c4">Group validators run</span></li><li class="c9 c19"><span class="c23">Group errors set</span></li></ul><p class="c9"><span class="c4">One option is to wrap errors in an object that contains a </span><span class="c29">onlySelf</span><span class="c5 c4">&nbsp;property if you need to pass the config through:</span></p><a id="t.9eb34afcebcc4e5f0858c2fad85b9329214ae4e4"></a><a id="t.39"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c14">function</span><span class="c3">&nbsp;defaultChain</span><span class="c0">(</span><span class="c3">ctrl</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c17">AbstractControl</span><span class="c0">):</span><span class="c3">&nbsp;</span><span class="c17">Observable</span><span class="c0">&lt;</span><span class="c17">ValidationErrors</span><span class="c0">|</span><span class="c14">null</span><span class="c0">&gt;</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c14">return</span><span class="c3">&nbsp;</span><span class="c0">(</span><span class="c3">obs</span><span class="c0">)</span><span class="c3">&nbsp;</span><span class="c0">=&gt;</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; </span><span class="c14">return</span><span class="c3">&nbsp;obs</span><span class="c0">.</span><span class="c3">map</span><span class="c0">(</span><span class="c3">ctrl</span><span class="c0">.</span><span class="c3">validator</span><span class="c0">)</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">.</span><span class="c3">switchMap</span><span class="c0">(</span><span class="c3">errs </span><span class="c0">=&gt;</span><span class="c3">&nbsp;</span><span class="c0">{</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c14">return</span><span class="c3">&nbsp;errs </span><span class="c0">||</span><span class="c3">&nbsp;</span><span class="c0">!</span><span class="c3">ctrl</span><span class="c0">.</span><span class="c3 c6">asyncValidator </span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">?</span><span class="c3">&nbsp;</span><span class="c17">Observable</span><span class="c0">.</span><span class="c3">of</span><span class="c0">({</span><span class="c3">errors</span><span class="c0">:</span><span class="c3">&nbsp;errs</span><span class="c0">,</span><span class="c3">&nbsp;onlySelf</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c14">true</span><span class="c0">})</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">:</span><span class="c3">&nbsp;ctrl</span><span class="c0">.</span><span class="c3">asyncValidator</span><span class="c0">(</span><span class="c3">ctrl</span><span class="c0">);</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">});</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;</span><span class="c0">};</span></p><p class="c2"><span class="c0">}</span></p></td></tr></tbody></table><p class="c9"><span class="c4">If </span><span class="c29">onlySelf</span><span class="c5 c4">&nbsp;is true, we don&rsquo;t update the tree and the group is updated as soon as its validators run. This optimization can be added to our default chain. Developers implementing their own chains can decide whether the modest performance gain is necessary.</span></p><h1 class="c30" id="h.s30znup8hx9j"><span class="c6 c4 c39">Performance Considerations</span></h1><p class="c9"><span class="c5 c4">By and large, adding rate limiting functionality should improve application performance. Apps with more expensive validation will be able to gate it from running until absolutely necessary and control how it runs.</span></p><p class="c9"><span class="c5 c4">To implement the feature, we will need to bring in a few more rxjs operators, specifically:</span></p><ul class="c33 lst-kix_qy1l883yv1pi-0 start"><li class="c9 c19"><span class="c5 c4">let</span></li><li class="c9 c19"><span class="c5 c4">debounceTime</span></li><li class="c9 c19"><span class="c5 c4">switchMap</span></li><li class="c9 c19"><span class="c5 c4">filter</span></li><li class="c9 c19"><span class="c5 c4">combineLatest</span></li><li class="c9 c19"><span class="c5 c4">distinctUntilChanged</span></li></ul><p class="c9"><span class="c4">And we&#39;ll be removing our dependence on the </span><span class="c29">forkJoin</span><span class="c5 c4">&nbsp;operator.</span></p><p class="c9"><span class="c4">By carefully importing only the operators we need, the payload size increase for these functions should be </span><span class="c4">modest</span><span class="c5 c4">.</span></p><p class="c9"><span class="c5 c4">Forms UMD bundle now: 97KB<br>Forms UMD bundle with rxjs operators added: 98KB</span></p><h1 class="c9 c36" id="h.noz0lcm3n4bc"><span class="c6 c4 c39">Documentation Plan</span></h1><p class="c2 c25"><span class="c4">We will likely need to add the new </span><span class="c29">debounce</span><span class="c4">&nbsp;and </span><span class="c29">updateOn</span><span class="c5 c4">&nbsp;options to the existing validation cookbook. For validator chains, we&#39;ll likely need a new cookbook.</span></p><p class="c2 c12"><span class="c5 c4"></span></p><p class="c2 c25"><span class="c5 c4">To simplify matters, I can adapt some of the examples in this doc to provide a rough draft of a cookbook. It would expedite the process to have help from someone on the docs team who is familiar with adding running examples / tests.</span></p><p class="c2 c12"><span class="c5 c4"></span></p><h1 class="c46 c36" id="h.f8v52nuwh41m"><span class="c6 c4 c39">Public API Surface Impact</span></h1><p class="c2 c12"><span class="c6 c23 c27"></span></p><ol class="c33 lst-kix_cjef3nglei0n-0 start" start="1"><li class="c2 c25 c19"><span class="c4">We&#39;ll be changing the type of the second argument of </span><span class="c29">FormControls</span><span class="c4">, </span><span class="c29">FormGroups</span><span class="c4">, and </span><span class="c29">FormArrays</span><span class="c4">&nbsp;to allow passing in an options map. The map will accept four properties: </span><span class="c29">debounce</span><span class="c4">, </span><span class="c29">updateOn,</span><span class="c4">&nbsp;</span><span class="c29">validators</span><span class="c4">, </span><span class="c29">asyncValidators</span><span class="c4">, and </span><span class="c29">validatorChain</span><span class="c5 c4">. </span></li><li class="c2 c25 c19"><span class="c29">FormControl</span><span class="c5 c4">&nbsp;will now have a subscribe method.</span></li><li class="c2 c25 c19"><span class="c4">The </span><span class="c29">statusChanges</span><span class="c4">&nbsp;observable will now be run through </span><span class="c29">distinctUntilChanged.</span></li></ol><p class="c2 c12"><span class="c5 c4"></span></p><h1 class="c36 c46" id="h.233adhaen7x0"><span class="c6 c4 c39">Developer Experience Impact / Breaking Changes</span></h1><p class="c2 c12"><span class="c5 c4"></span></p><p class="c2 c25"><span class="c5 c4">Developers using reactive form directives will have to begin managing subscriptions for their controls, either by adding an async pipe or calling the methods directly. </span></p><p class="c2 c12"><span class="c6 c4 c27"></span></p><p class="c2 c25"><span class="c5 c4">Aside from that, breaking changes should be minimal. We are tweaking a few validation behaviors, which may have consequences in a small number of apps.</span></p><p class="c2 c12"><span class="c5 c4"></span></p><p class="c2 c25"><span class="c4">There may be breaking changes in an application if one of its async validators emits multiple values and these intermediate values should *not* be used to apply errors. (Previously, all but the last value before completing would be ignored).</span></p><p class="c2 c12"><span class="c6 c4 c27"></span></p><h1 class="c46 c36" id="h.58dh65dile54"><span class="c6 c4 c39">Maintenance Plan</span></h1><p class="c2 c12"><span class="c5 c4"></span></p><p class="c2 c25"><span class="c5 c4">One thing to consider is where we will pass in parsers and formatters when we add support. We could simply add them to the options argument:</span></p><p class="c2 c12"><span class="c5 c4"></span></p><a id="t.1b283beb7101d03243ce262cc7e28fbee43ccfc6"></a><a id="t.40"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c3">ctrl </span><span class="c0">=</span><span class="c3">&nbsp;</span><span class="c14">new</span><span class="c3">&nbsp;</span><span class="c17">FormControl</span><span class="c0">(</span><span class="c43">&#39;&#39;</span><span class="c0">,{</span><span class="c3">parsers</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c0">[],</span><span class="c3">&nbsp;formatters</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c0">[]})</span></p></td></tr></tbody></table><p class="c2 c12"><span class="c6 c4 c27"></span></p><p class="c2 c25"><span class="c4">That said, we do need to be careful about making </span><span class="c29">options</span><span class="c5 c4">&nbsp;into a general &quot;bucket&quot; for every new feature. &nbsp;One suggestion was to also support the builder pattern, which could be an optimization down the line.</span></p><p class="c2 c12"><span class="c5 c4"></span></p><a id="t.f24589024352eca9036c287792fa55d3598275b7"></a><a id="t.41"></a><table class="c31"><tbody><tr class="c22"><td class="c8" colspan="1" rowspan="1"><p class="c2"><span class="c3">ctrl </span><span class="c0">=</span><span class="c3">&nbsp;</span><span class="c14">new</span><span class="c3">&nbsp;</span><span class="c17">FormControl</span><span class="c0">(</span><span class="c43">&#39;&#39;</span><span class="c0">,{</span><span class="c3">validators</span><span class="c0">:</span><span class="c3">&nbsp;</span><span class="c0">[]})</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">.</span><span class="c3">withParsers</span><span class="c0">([])</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">.</span><span class="c3">withFormatters</span><span class="c0 c6">({});</span></p></td></tr></tbody></table><p class="c2 c12"><span class="c5 c4"></span></p><p class="c2 c12"><span class="c5 c4"></span></p><a id="id.ac7jz47skyry"></a><h1 class="c30" id="h.bruck9vnuopk"><span class="c4 c42">Work Breakdown / Rollout plan</span></h1><p class="c2 c25"><span class="c20 c7">Updated: July 24, 2017</span></p><p class="c2 c12"><span class="c5 c7"></span></p><p class="c2 c25"><span class="c5 c7">Given that this is a fairly large proposal and there are only a few weeks before the v5 RC period, we will likely need to split development efforts between v5 and v6.</span></p><p class="c2 c12"><span class="c5 c7"></span></p><p class="c2 c25"><span class="c5 c7">For v5, we&#39;d like to target mostly non-breaking, additive changes in painful areas. With that in mind, we will focus first on our two most frequent validation requests: </span></p><ul class="c33 lst-kix_lr61fncf3c7x-0 start"><li class="c2 c25 c19"><span class="c5 c7">updating fields only on &quot;blur&quot;</span></li><li class="c2 c25 c19"><span class="c5 c7">updating fields only on &quot;submit&quot;</span></li></ul><p class="c2 c12"><span class="c5 c7"></span></p><p class="c2 c25"><span class="c5 c7">Implementing these two features will not require significant breaking changes or time-intensive internal rewrites.</span></p><p class="c2 c12"><span class="c5 c7"></span></p><p class="c2 c25"><span class="c5 c7">Work slated for v5</span></p><p class="c2 c12"><span class="c5 c7"></span></p><a id="t.63f440690cb7ea7f7071401c925918e1125c52e3"></a><a id="t.42"></a><table class="c31"><tbody><tr class="c22"><td class="c1" colspan="1" rowspan="1"><p class="c13"><span class="c5 c40">Task</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c13"><span class="c5 c40">Estimated time</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c13"><span class="c5 c40">Status</span></p></td></tr><tr class="c22"><td class="c1" colspan="1" rowspan="1"><p class="c13"><span class="c5 c7">Add options argument to Abstract Controls</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c13"><span class="c5 c7">1-2 days</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c13"><span class="c16"><a class="c15" href="https://www.google.com/url?q=https://github.com/angular/angular/pull/18333&amp;sa=D&amp;ust=1514893617462000&amp;usg=AFQjCNFYAeGRe9gno-awPfTtOL4IXYCNvg">Done</a></span></p></td></tr><tr class="c22"><td class="c1" colspan="1" rowspan="1"><p class="c13"><span>Add </span><span class="c29">updateOn</span><span class="c5 c7">&nbsp;option for blur to AbstractControls </span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c13"><span class="c5 c7">2 days</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c13"><span class="c16"><a class="c15" href="https://www.google.com/url?q=https://github.com/angular/angular/pull/18408&amp;sa=D&amp;ust=1514893617463000&amp;usg=AFQjCNEUFPjIW5G8f-6-0dkZ-VFFNzOctA">Done</a></span></p></td></tr><tr class="c22"><td class="c1" colspan="1" rowspan="1"><p class="c13"><span>Add </span><span class="c29">updateOn</span><span class="c5 c7">&nbsp;option for submit to AbstractControls </span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c13"><span class="c5 c7">2 days</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c13"><span class="c16"><a class="c15" href="https://www.google.com/url?q=https://github.com/angular/angular/pull/18514&amp;sa=D&amp;ust=1514893617463000&amp;usg=AFQjCNH6Hpqhp7VuV0Lc8PrTWVtwmWbfAg">Done</a></span></p></td></tr><tr class="c22"><td class="c1" colspan="1" rowspan="1"><p class="c13"><span>Add group support for </span><span class="c29">updateOn</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c13"><span class="c5 c7">2 days </span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c13"><span class="c16"><a class="c15" href="https://www.google.com/url?q=https://github.com/angular/angular/pull/18536&amp;sa=D&amp;ust=1514893617464000&amp;usg=AFQjCNHEPgYPKk5-_xYL0MQU3S0MTWWXDg">Done</a></span></p></td></tr><tr class="c22"><td class="c1" colspan="1" rowspan="1"><p class="c13"><span class="c5 c7">ngModelOptions / ngFormOptions</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c13"><span class="c5 c7">2 days</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c13"><span>Waiting for merge (</span><span class="c16"><a class="c15" href="https://www.google.com/url?q=https://github.com/angular/angular/pull/18577&amp;sa=D&amp;ust=1514893617465000&amp;usg=AFQjCNEMTEK81hEVaBqxZH6Qx0SR4UJqeA">#18577</a></span><span>), Waiting for review (</span><span class="c16"><a class="c15" href="https://www.google.com/url?q=https://github.com/angular/angular/pull/18594&amp;sa=D&amp;ust=1514893617465000&amp;usg=AFQjCNEmhhwMlnJKaTTrdeNYFredTgZd7w">#18594</a></span><span class="c5 c7">)</span></p></td></tr><tr class="c22"><td class="c1" colspan="1" rowspan="1"><p class="c13"><span class="c5 c7">Documentation updates</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c13"><span class="c5 c7">3 days</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c13"><span>In progress (</span><span class="c16"><a class="c15" href="https://www.google.com/url?q=https://github.com/angular/angular/pull/18495&amp;sa=D&amp;ust=1514893617466000&amp;usg=AFQjCNHeumaRJzFgUqx3dND7_iDkSkGJcA">#18495</a></span><span>, more to come</span><span class="c5 c7">)</span></p></td></tr></tbody></table><p class="c2 c12"><span class="c5 c7"></span></p><p class="c2 c12"><span class="c5 c7"></span></p><p class="c2 c25"><span class="c5 c7">Work slated for v6</span></p><p class="c2 c12"><span class="c5 c7"></span></p><a id="t.7483933858cd7e515639350a4f2f843af1e36387"></a><a id="t.43"></a><table class="c31"><tbody><tr class="c22"><td class="c26" colspan="1" rowspan="1"><p class="c13"><span class="c5 c40">Task</span></p></td><td class="c26" colspan="1" rowspan="1"><p class="c13"><span class="c5 c40">Estimated time</span></p></td></tr><tr class="c22"><td class="c26" colspan="1" rowspan="1"><p class="c13"><span class="c5 c7">Internal refactor to use reactive constructs</span></p></td><td class="c26" colspan="1" rowspan="1"><p class="c13"><span class="c5 c7">2-3 weeks</span></p></td></tr><tr class="c22"><td class="c26" colspan="1" rowspan="1"><p class="c13"><span>Debounce support in </span><span class="c29">updateOn</span></p></td><td class="c26" colspan="1" rowspan="1"><p class="c13"><span class="c5 c7">2-3 days</span></p></td></tr><tr class="c22"><td class="c26" colspan="1" rowspan="1"><p class="c13"><span>Support </span><span class="c29">validatorChain</span><span class="c5 c7">&nbsp;option in Abstract Controls</span></p></td><td class="c26" colspan="1" rowspan="1"><p class="c13"><span class="c5 c7">2-3 days</span></p></td></tr></tbody></table><p class="c2 c12"><span class="c5 c7"></span></p></body></html>